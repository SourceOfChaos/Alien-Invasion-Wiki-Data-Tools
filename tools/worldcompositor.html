<!DOCTYPE html>

<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>WorldCompositor</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Outfit:wght@300;400;500;600&display=swap');

:root {
â€“bg:     #0a0c10;
â€“surf:   #12151e;
â€“surf2:  #1a1f2e;
â€“surf3:  #222840;
â€“border: #2a3350;
â€“text:   #d0d8f0;
â€“dim:    #4a5580;
â€“accent: #e8ff47;
â€“cyan:   #47ffe8;
â€“danger: #ff4757;
â€“snap:   #ff9f43;

/* Layer colors */
â€“c-room:    #47ffe8;
â€“c-gate:    #e8ff47;
â€“c-wall:    #778ca3;
â€“c-spawn:   #ff6b81;
â€“c-farm:    #55efc4;
â€“c-market:  #fdcb6e;
â€“c-mission: #a29bfe;
â€“c-default: #74b9ff;
}

- { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }

body {
background: var(â€“bg);
color: var(â€“text);
font-family: â€˜Outfitâ€™, sans-serif;
height: 100dvh;
display: flex;
flex-direction: column;
overflow: hidden;
user-select: none;
-webkit-user-select: none;
}

/* â”€â”€ HEADER â”€â”€ */
header {
display: flex;
align-items: center;
justify-content: space-between;
padding: 8px 12px;
background: var(â€“surf);
border-bottom: 1px solid var(â€“border);
flex-shrink: 0;
gap: 8px;
}
.logo {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 12px;
color: var(â€“cyan);
letter-spacing: 2px;
white-space: nowrap;
}
.hbtns { display: flex; gap: 5px; flex-wrap: wrap; }

/* â”€â”€ TOOLBAR â”€â”€ */
.toolbar {
display: flex;
align-items: center;
gap: 5px;
padding: 6px 12px;
background: var(â€“surf);
border-bottom: 1px solid var(â€“border);
flex-shrink: 0;
overflow-x: auto;
scrollbar-width: none;
}
.toolbar::-webkit-scrollbar { display: none; }
.tsep { width: 1px; height: 18px; background: var(â€“border); flex-shrink: 0; }

/* â”€â”€ BUTTONS â”€â”€ */
.btn {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 10px;
letter-spacing: 1px;
padding: 6px 10px;
border: 1px solid var(â€“border);
background: var(â€“surf2);
color: var(â€“text);
border-radius: 4px;
cursor: pointer;
white-space: nowrap;
flex-shrink: 0;
transition: opacity .1s;
}
.btn:active { opacity: .7; }
.btn.on    { background: var(â€“accent); color: #0a0c10; border-color: var(â€“accent); }
.btn.cyan  { border-color: var(â€“cyan); color: var(â€“cyan); }
.btn.snap  { border-color: var(â€“snap); color: var(â€“snap); }
.btn.snap.on { background: var(â€“snap); color: #0a0c10; }
.btn.danger { border-color: var(â€“danger); color: var(â€“danger); }
.btn.exp   { border-color: var(â€“accent); color: var(â€“accent); }
.btn[disabled] { opacity: .3; pointer-events: none; }

/* â”€â”€ STATUS â”€â”€ */
.statusbar {
display: flex; gap: 10px;
padding: 4px 12px;
background: var(â€“bg);
border-bottom: 1px solid var(â€“border);
flex-shrink: 0;
overflow-x: auto;
scrollbar-width: none;
}
.statusbar::-webkit-scrollbar { display: none; }
.chip {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 10px;
color: var(â€“dim);
white-space: nowrap;
}
.chip b { color: var(â€“cyan); font-weight: 400; }

/* â”€â”€ CANVAS â”€â”€ */
#wrap {
flex: 1;
position: relative;
overflow: hidden;
background: var(â€“bg);
touch-action: none;
}

/* Subtle grid background */
#wrap::before {
content: â€˜â€™;
position: absolute;
inset: 0;
background-image:
linear-gradient(var(â€“surf2) 1px, transparent 1px),
linear-gradient(90deg, var(â€“surf2) 1px, transparent 1px);
background-size: 60px 60px;
opacity: .4;
pointer-events: none;
}

#svg {
position: absolute;
inset: 0;
width: 100%; height: 100%;
overflow: visible;
}

/* â”€â”€ PANELS â”€â”€ */
.panel-overlay {
display: none;
position: fixed;
inset: 0;
z-index: 50;
background: #000b;
align-items: flex-start;
}
.panel-overlay.open { display: flex; }
.panel-inner {
background: var(â€“surf);
border: 1px solid var(â€“border);
border-top: none;
border-radius: 0 0 8px 8px;
width: 100%;
max-height: 60vh;
overflow-y: auto;
margin-top: 96px;
}

.pitem {
display: flex; align-items: center; gap: 8px;
padding: 10px 14px;
border-bottom: 1px solid var(â€“border);
cursor: pointer;
}
.pitem:last-child { border-bottom: none; }
.pitem:active { background: var(â€“surf2); }
.pitem.active { background: #47ffe820; }
.pdot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
.pname {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 12px;
color: #fff;
flex: 1;
overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.pitem.active .pname { color: var(â€“cyan); }
.pbadge {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 9px;
padding: 2px 5px;
border-radius: 3px;
flex-shrink: 0;
}
.pdel { font-size: 14px; color: var(â€“dim); padding: 2px 6px; flex-shrink: 0; }
.pempty {
padding: 16px;
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 11px;
color: var(â€“dim);
text-align: center;
}

/* â”€â”€ EMPTY STATE â”€â”€ */
#empty {
position: absolute; inset: 0;
display: flex; flex-direction: column;
align-items: center; justify-content: center;
gap: 12px; pointer-events: none;
}
.eico { font-size: 40px; opacity: .2; }
.etxt {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 11px; color: var(â€“dim);
text-align: center; line-height: 2; letter-spacing: 1px;
}

/* â”€â”€ SNAP INDICATOR â”€â”€ */
#snap-dot {
display: none;
position: absolute;
width: 16px; height: 16px;
border-radius: 50%;
background: var(â€“snap);
opacity: .8;
pointer-events: none;
transform: translate(-50%, -50%);
z-index: 30;
}

/* â”€â”€ MODALS â”€â”€ */
.modal-bg {
display: none; position: fixed; inset: 0;
background: #000c; z-index: 200;
align-items: center; justify-content: center; padding: 16px;
}
.modal-bg.open { display: flex; }
.modal {
background: var(â€“surf);
border: 1px solid var(â€“border);
border-radius: 10px;
padding: 18px; width: 100%; max-width: 320px;
}
.mtitle {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 12px; color: var(â€“cyan);
letter-spacing: 2px; margin-bottom: 14px;
}
.flabel {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 10px; color: var(â€“dim);
letter-spacing: 1px; margin-bottom: 5px;
}
.finput {
width: 100%;
background: var(â€“bg); border: 1px solid var(â€“border);
color: var(â€“text);
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 13px; padding: 9px 11px; border-radius: 4px; outline: none;
margin-bottom: 10px;
}
.finput:focus { border-color: var(â€“cyan); }
.frow { display: flex; gap: 8px; }
.frow .finput { flex: 1; }
.fhint { font-size: 10px; color: var(â€“dim); margin-top: -6px; margin-bottom: 10px; line-height: 1.5; }
.mbtns { display: flex; gap: 8px; justify-content: flex-end; margin-top: 4px; }

/* â”€â”€ ROI PROPERTY PANEL â”€â”€ */
#prop-panel {
position: absolute;
bottom: 0; left: 0; right: 0;
background: var(â€“surf);
border-top: 1px solid var(â€“border);
padding: 10px 14px;
z-index: 20;
display: none;
}
#prop-panel.open { display: block; }
.prop-row {
display: flex; gap: 6px; align-items: center;
flex-wrap: wrap;
}
.prop-label {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 10px; color: var(â€“dim);
white-space: nowrap;
}
.prop-name {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 12px; color: var(â€“accent);
flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.layer-pill {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 9px;
padding: 3px 7px;
border-radius: 3px;
cursor: pointer;
border: 1px solid currentColor;
}

/* â”€â”€ LAYER SELECTOR â”€â”€ */
#layer-panel {
display: none;
position: fixed;
bottom: 60px; left: 12px; right: 12px;
background: var(â€“surf);
border: 1px solid var(â€“border);
border-radius: 8px;
z-index: 60;
overflow: hidden;
}
#layer-panel.open { display: block; }
.layer-item {
display: flex; align-items: center; gap: 10px;
padding: 10px 14px;
border-bottom: 1px solid var(â€“border);
cursor: pointer;
}
.layer-item:last-child { border-bottom: none; }
.layer-item:active { background: var(â€“surf2); }
.layer-dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
.layer-name {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 12px; color: #fff;
}

/* â”€â”€ GROUP PANEL â”€â”€ */
#group-panel {
display: none;
position: fixed;
bottom: 60px; left: 12px; right: 12px;
background: var(â€“surf);
border: 1px solid var(â€“border);
border-radius: 8px;
z-index: 60;
overflow: hidden;
max-height: 40vh;
overflow-y: auto;
}
#group-panel.open { display: block; }

/* â”€â”€ MERGE SELECT â”€â”€ */
.merge-badge {
position: absolute;
top: -8px; right: -8px;
background: var(â€“accent);
color: #0a0c10;
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 9px;
padding: 1px 4px;
border-radius: 3px;
pointer-events: none;
}
</style>

</head>
<body>

<header>
  <div class="logo">â—ˆ WORLDCOMPOSITOR</div>
  <div class="hbtns">
    <button class="btn cyan" id="btn-load">ï¼‹ JSON</button>
    <button class="btn exp" id="btn-export" disabled>â¬‡ EXPORT</button>
  </div>
</header>

<div class="toolbar">
  <button class="btn" id="btn-rois">â˜° ROIs <span id="roi-count"></span></button>
  <div class="tsep"></div>
  <button class="btn" id="btn-addpt" style="display:none">ï¼‹ PUNKT</button>
  <button class="btn danger" id="btn-merge" style="display:none">âŠ• MERGE</button>
  <button class="btn danger" id="btn-merge-confirm" style="display:none">âœ“ MERGE</button>
  <div class="tsep"></div>
  <button class="btn snap on" id="btn-snap">âŠ¡ SNAP</button>
  <div class="tsep"></div>
  <button class="btn" id="btn-layers">LAYER â–¾</button>
</div>

<div class="statusbar">
  <div class="chip">ROIs <b id="sc-total">0</b></div>
  <div class="chip">AKTIV <b id="sc-active">â€”</b></div>
  <div class="chip">LAYER <b id="sc-layer">â€”</b></div>
  <div class="chip">GRUPPE <b id="sc-group">â€”</b></div>
  <div class="chip">SNAP <b id="sc-snap">AN</b></div>
</div>

<div id="wrap">
  <svg id="svg" xmlns="http://www.w3.org/2000/svg">
    <g id="l-rois"></g>
    <g id="l-handles"></g>
    <g id="l-snap"></g>
  </svg>
  <div id="empty">
    <div class="eico">ðŸ—º</div>
    <div class="etxt">JSON LADEN<br>â†’ LAYER ZUWEISEN<br>â†’ GRUPPEN BILDEN<br>â†’ ZUSAMMENFÃœHREN<br>â†’ EXPORTIEREN</div>
  </div>
  <div id="snap-dot"></div>
</div>

<!-- ROI Property Panel -->

<div id="prop-panel">
  <div class="prop-row">
    <span class="prop-label">ROI:</span>
    <span class="prop-name" id="prop-name">â€”</span>
    <span class="layer-pill" id="prop-layer-pill" style="display:none" onclick="openLayerPanel()"></span>
    <button class="btn" style="padding:4px 7px;font-size:9px" id="prop-rename-btn">âœŽ</button>
    <button class="btn" style="padding:4px 7px;font-size:9px" id="prop-group-btn">âŠž GRP</button>
    <button class="btn danger" style="padding:4px 7px;font-size:9px" id="prop-del-btn">âœ•</button>
  </div>
</div>

<!-- ROI List Panel -->

<div class="panel-overlay" id="roi-panel">
  <div class="panel-inner" id="roi-panel-inner"></div>
</div>

<!-- Layer Visibility Panel -->

<div class="panel-overlay" id="layer-vis-panel">
  <div class="panel-inner" id="layer-vis-inner"></div>
</div>

<!-- Layer Selector (for active ROI) -->

<div id="layer-panel"></div>

<!-- Group Panel -->

<div id="group-panel"></div>

<!-- File Input -->

<input type="file" id="finput" accept=".json,application/json" style="display:none">

<!-- Modal: Rename -->

<div class="modal-bg" id="m-rename">
  <div class="modal">
    <div class="mtitle">UMBENENNEN</div>
    <div class="flabel">NAME</div>
    <input class="finput" id="m-rename-input" type="text" autocomplete="off">
    <div class="mbtns">
      <button class="btn" id="m-rename-cancel">ABBRUCH</button>
      <button class="btn on" id="m-rename-ok">OK</button>
    </div>
  </div>
</div>

<!-- Modal: Group -->

<div class="modal-bg" id="m-group">
  <div class="modal">
    <div class="mtitle">GRUPPE ZUWEISEN</div>
    <div class="flabel">GRUPPENNAME (leer = keine Gruppe)</div>
    <input class="finput" id="m-group-input" type="text" autocomplete="off" placeholder="z.B. Kustov_Block">
    <div class="fhint">Gruppen werden beim Export gespeichert.<br>Alle ROIs einer Gruppe verschieben sich gemeinsam.</div>
    <div class="mbtns">
      <button class="btn" id="m-group-cancel">ABBRUCH</button>
      <button class="btn on" id="m-group-ok">ZUWEISEN</button>
    </div>
  </div>
</div>

<!-- Modal: Merge confirm -->

<div class="modal-bg" id="m-merge">
  <div class="modal">
    <div class="mtitle">POLYGONE MERGEN</div>
    <div id="m-merge-info" style="font-family:'Share Tech Mono',monospace;font-size:11px;color:var(--dim);margin-bottom:14px;line-height:1.6"></div>
    <div class="flabel">NAME DES NEUEN POLYGONS</div>
    <input class="finput" id="m-merge-name" type="text" autocomplete="off">
    <div class="mbtns">
      <button class="btn" id="m-merge-cancel">ABBRUCH</button>
      <button class="btn on" id="m-merge-ok">MERGEN</button>
    </div>
  </div>
</div>

<script>
'use strict';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LAYER DEFINITIONS â€” add new layers here
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const LAYERS = [
  { id: 'room',    label: 'Room',         color: '#47ffe8' },
  { id: 'gate',    label: 'Gate',         color: '#e8ff47' },
  { id: 'wall',    label: 'Wall',         color: '#778ca3' },
  { id: 'spawn',   label: 'Spawn Point',  color: '#ff6b81' },
  { id: 'farm',    label: 'Farm',         color: '#55efc4' },
  { id: 'market',  label: 'Market',       color: '#fdcb6e' },
  { id: 'mission', label: 'Mission Spot', color: '#a29bfe' },
  { id: 'none',    label: 'â€” kein Layer', color: '#74b9ff' },
];

function layerById(id) {
  return LAYERS.find(l => l.id === id) || LAYERS[LAYERS.length - 1];
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let S = {
  rois: [],        // all ROI objects across all JSONs
  activeId: null,
  snapOn: true,
  mergeMode: false,
  mergeIds: [],    // up to 2 selected for merge
  vb: { x: -200, y: -200, w: 3000, h: 6000 },
  drag: null,
  pan: null,
  _seq: 0,
  layerVisibility: {},  // layerId -> bool
  hiddenPanels: new Set(),
};

LAYERS.forEach(l => { S.layerVisibility[l.id] = true; });

const SNAP_RADIUS_SVG = 30; // snap distance in SVG units
const HANDLE_R = 12;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DOM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const NS = 'http://www.w3.org/2000/svg';
const wrap       = document.getElementById('wrap');
const svgEl      = document.getElementById('svg');
const lRois      = document.getElementById('l-rois');
const lHandles   = document.getElementById('l-handles');
const emptyEl    = document.getElementById('empty');
const snapDot    = document.getElementById('snap-dot');
const propPanel  = document.getElementById('prop-panel');
const propName   = document.getElementById('prop-name');
const propLayerPill = document.getElementById('prop-layer-pill');

const btnLoad    = document.getElementById('btn-load');
const btnExport  = document.getElementById('btn-export');
const btnRois    = document.getElementById('btn-rois');
const btnSnap    = document.getElementById('btn-snap');
const btnLayers  = document.getElementById('btn-layers');
const btnAddPt   = document.getElementById('btn-addpt');
const btnMerge   = document.getElementById('btn-merge');
const btnMergeConfirm = document.getElementById('btn-merge-confirm');
const roiCount   = document.getElementById('roi-count');
const fileInput  = document.getElementById('finput');

const scTotal  = document.getElementById('sc-total');
const scActive = document.getElementById('sc-active');
const scLayer  = document.getElementById('sc-layer');
const scGroup  = document.getElementById('sc-group');
const scSnap   = document.getElementById('sc-snap');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UTILS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function uid() { return 'c' + (++S._seq); }
function mk(tag, attrs) {
  const el = document.createElementNS(NS, tag);
  for (const [k,v] of Object.entries(attrs)) el.setAttribute(k, v);
  return el;
}
function clientToSvg(cx, cy) {
  const rect = wrap.getBoundingClientRect();
  return {
    x: S.vb.x + (cx - rect.left) / rect.width  * S.vb.w,
    y: S.vb.y + (cy - rect.top)  / rect.height * S.vb.h,
  };
}
function applyVB() {
  svgEl.setAttribute('viewBox', `${S.vb.x} ${S.vb.y} ${S.vb.w} ${S.vb.h}`);
}
function svgToScreen(svgPt) {
  const rect = wrap.getBoundingClientRect();
  return {
    x: rect.left + (svgPt.x - S.vb.x) / S.vb.w * rect.width,
    y: rect.top  + (svgPt.y - S.vb.y) / S.vb.h * rect.height,
  };
}
function getRoi(id) { return S.rois.find(r => r.id === id); }

function openModal(m) {
  m.classList.add('open');
  setTimeout(() => m.querySelector('input')?.focus(), 80);
}
function closeModal(m) { m.classList.remove('open'); }
function closeAllPanels() {
  document.getElementById('roi-panel').classList.remove('open');
  document.getElementById('layer-vis-panel').classList.remove('open');
  document.getElementById('layer-panel').classList.remove('open');
  document.getElementById('group-panel').classList.remove('open');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JSON IMPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
btnLoad.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', e => {
  const files = Array.from(e.target.files);
  files.forEach(file => {
    const reader = new FileReader();
    reader.onload = ev => {
      try {
        const data = JSON.parse(ev.target.result);
        importJSON(data);
      } catch(err) {
        alert('UngÃ¼ltiges JSON: ' + err.message);
      }
    };
    reader.readAsText(file);
  });
  fileInput.value = '';
});

function importJSON(data) {
  // Support both Tool1 format and Tool2 (compositor) format
  const rois = data.rois || [];
  const unitPerPx = data.meta?.unitPerPx || 1;

  // Calculate auto-offset: place new JSONs to the right of existing content
  let offsetX = 0;
  if (S.rois.length > 0) {
    let maxX = -Infinity;
    S.rois.forEach(roi => {
      if (roi.type === 'circle') {
        maxX = Math.max(maxX, (roi.geo.cx + roi.geo.r));
      } else {
        roi.geo.points.forEach(p => { maxX = Math.max(maxX, p.x); });
      }
    });
    offsetX = maxX + 200; // 200 unit gap
  }

  rois.forEach(r => {
    if (r.isCalibrationROI) return; // skip calibration circles

    const layer = r.layer || 'none';
    const group = r.group || '';

    let geo, type;
    if (r.type === 'circle') {
      const u = r.units || { cx: r.pixels.cx * unitPerPx, cy: r.pixels.cy * unitPerPx, r: r.pixels.r * unitPerPx };
      type = 'circle';
      geo = { cx: u.cx + offsetX, cy: u.cy, r: u.r };
    } else {
      const u = r.units || { points: r.pixels.points.map(p => ({ x: p.x * unitPerPx, y: p.y * unitPerPx })) };
      type = 'polygon';
      // Deduplicate near-identical points
      const pts = deduplicatePoints(u.points.map(p => ({ x: p.x + offsetX, y: p.y })));
      geo = { points: pts };
    }

    const roi = {
      id: uid(),
      name: r.name || ('ROI_' + S._seq),
      type,
      layer,
      group,
      geo,
      svgG: null,
    };
    S.rois.push(roi);
    buildRoiSvg(roi);
  });

  updateEmpty();
  fitView();
  updateStatus();
  renderRoiList();
  btnExport.disabled = false;
}

function deduplicatePoints(pts) {
  const result = [pts[0]];
  for (let i = 1; i < pts.length; i++) {
    const prev = result[result.length - 1];
    const d = Math.hypot(pts[i].x - prev.x, pts[i].y - prev.y);
    if (d > 0.5) result.push(pts[i]);
  }
  return result;
}

function fitView() {
  if (!S.rois.length) return;
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  S.rois.forEach(roi => {
    if (roi.type === 'circle') {
      minX = Math.min(minX, roi.geo.cx - roi.geo.r);
      minY = Math.min(minY, roi.geo.cy - roi.geo.r);
      maxX = Math.max(maxX, roi.geo.cx + roi.geo.r);
      maxY = Math.max(maxY, roi.geo.cy + roi.geo.r);
    } else {
      roi.geo.points.forEach(p => {
        minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
      });
    }
  });
  const pad = 200;
  S.vb.x = minX - pad; S.vb.y = minY - pad;
  S.vb.w = (maxX - minX) + pad * 2;
  S.vb.h = (maxY - minY) + pad * 2;
  applyVB();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BUILD ROI SVG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildRoiSvg(roi) {
  if (roi.svgG) roi.svgG.remove();
  lHandles.querySelectorAll(`[data-hroi="${roi.id}"]`).forEach(e => e.remove());

  const isActive = roi.id === S.activeId;
  const isMergeSelected = S.mergeIds.includes(roi.id);
  const layer = layerById(roi.layer);
  const color = layer.color;
  const visible = S.layerVisibility[roi.layer] !== false;

  const g = document.createElementNS(NS, 'g');
  g.dataset.roiId = roi.id;
  if (!visible) g.style.display = 'none';

  if (roi.type === 'circle') {
    const c = mk('circle', {
      cx: roi.geo.cx, cy: roi.geo.cy, r: roi.geo.r,
      fill: color + (isActive ? '70' : '55'),
      stroke: isMergeSelected ? '#ff4757' : color,
      'stroke-width': isActive ? 2.5 : 1,
      opacity: isActive ? 1 : 0.6,
      'pointer-events': 'none',
    });
    g.appendChild(c);

    // Label
    const txt = mk('text', {
      x: roi.geo.cx, y: roi.geo.cy,
      'text-anchor': 'middle',
      'dominant-baseline': 'middle',
      fill: color,
      'font-family': 'Share Tech Mono, monospace',
      'font-size': Math.max(12, roi.geo.r * 0.15),
      'pointer-events': 'none',
      opacity: 0.8,
    });
    txt.textContent = roi.name;
    g.appendChild(txt);
  } else {
    const poly = mk('polygon', {
      points: roi.geo.points.map(p => `${p.x},${p.y}`).join(' '),
      fill: color + (isActive ? '70' : '55'),
      stroke: isMergeSelected ? '#ff4757' : color,
      'stroke-width': isActive ? 2.5 : 1,
      opacity: isActive ? 1 : 0.6,
      'pointer-events': 'none',
    });
    g.appendChild(poly);

    // Label at centroid
    const cx = roi.geo.points.reduce((s,p) => s+p.x, 0) / roi.geo.points.length;
    const cy = roi.geo.points.reduce((s,p) => s+p.y, 0) / roi.geo.points.length;
    const txt = mk('text', {
      x: cx, y: cy,
      'text-anchor': 'middle',
      'dominant-baseline': 'middle',
      fill: color,
      'font-family': 'Share Tech Mono, monospace',
      'font-size': 18,
      'pointer-events': 'none',
      opacity: 0.85,
    });
    txt.textContent = roi.name;
    g.appendChild(txt);
  }

  lRois.appendChild(g);
  roi.svgG = g;

  if (isActive) buildHandles(roi);
}

function buildHandles(roi) {
  lHandles.querySelectorAll(`[data-hroi="${roi.id}"]`).forEach(e => e.remove());
  const color = layerById(roi.layer).color;

  if (roi.type === 'circle') {
    const ch = mk('circle', {
      cx: roi.geo.cx, cy: roi.geo.cy, r: HANDLE_R,
      fill: color, stroke: '#0a0c10', 'stroke-width': 2, cursor: 'move',
    });
    ch.dataset.hroi = roi.id; ch.dataset.htype = 'cc';
    lHandles.appendChild(ch);
    attachDrag(ch, roi, (roi, cur, sg, dx, dy) => {
      const grp = roi.group ? S.rois.filter(r => r.group === roi.group) : [roi];
      grp.forEach(r => {
        const orig = sg.groupGeos?.[r.id];
        if (!orig) return;
        if (r.type === 'circle') { r.geo.cx = orig.cx + dx; r.geo.cy = orig.cy + dy; }
        else r.geo.points.forEach((p, i) => { p.x = orig.points[i].x + dx; p.y = orig.points[i].y + dy; });
      });
    }, true);

    const rh = mk('rect', {
      x: roi.geo.cx + roi.geo.r - HANDLE_R, y: roi.geo.cy - HANDLE_R,
      width: HANDLE_R*2, height: HANDLE_R*2,
      fill: color, stroke: '#0a0c10', 'stroke-width': 2, rx: 2, cursor: 'ew-resize',
    });
    rh.dataset.hroi = roi.id; rh.dataset.htype = 'cr';
    lHandles.appendChild(rh);
    attachDrag(rh, roi, (roi, cur) => {
      roi.geo.r = Math.max(5, Math.hypot(cur.x - roi.geo.cx, cur.y - roi.geo.cy));
    });
  } else {
    roi.geo.points.forEach((p, i) => {
      const h = mk('circle', {
        cx: p.x, cy: p.y, r: HANDLE_R,
        fill: color, stroke: '#0a0c10', 'stroke-width': 2, cursor: 'move',
      });
      h.dataset.hroi = roi.id; h.dataset.htype = 'pv'; h.dataset.hi = i;
      lHandles.appendChild(h);
      attachDrag(h, roi, (roi, cur, sg, dx, dy) => {
        // Single point drag â€” with snap
        let tx = sg.points[i].x + dx;
        let ty = sg.points[i].y + dy;
        if (S.snapOn) {
          const snapped = findSnap(tx, ty, roi.id);
          if (snapped) { tx = snapped.x; ty = snapped.y; showSnapDot(tx, ty); }
          else hideSnapDot();
        }
        roi.geo.points[i].x = tx;
        roi.geo.points[i].y = ty;
      });

      // Long press = delete point
      let lpt = null;
      h.addEventListener('touchstart', () => {
        lpt = setTimeout(() => {
          if (roi.geo.points.length > 3) {
            roi.geo.points.splice(i, 1);
            rebuildRoi(roi);
          }
        }, 600);
      }, { passive: true });
      ['touchend','touchmove'].forEach(ev => h.addEventListener(ev, () => clearTimeout(lpt)));
    });
  }
}

function rebuildRoi(roi) { buildRoiSvg(roi); }

function rebuildAll() { S.rois.forEach(r => rebuildRoi(r)); }

// Sync SVG during drag (fast path)
function syncRoiSvg(roi) {
  if (!roi.svgG) return;
  const color = layerById(roi.layer).color;
  if (roi.type === 'circle') {
    const c = roi.svgG.querySelector('circle');
    if (c) { c.setAttribute('cx', roi.geo.cx); c.setAttribute('cy', roi.geo.cy); c.setAttribute('r', roi.geo.r); }
    const t = roi.svgG.querySelector('text');
    if (t) { t.setAttribute('x', roi.geo.cx); t.setAttribute('y', roi.geo.cy); }
    // handles
    const ch = lHandles.querySelector(`[data-htype="cc"][data-hroi="${roi.id}"]`);
    if (ch) { ch.setAttribute('cx', roi.geo.cx); ch.setAttribute('cy', roi.geo.cy); }
    const rh = lHandles.querySelector(`[data-htype="cr"][data-hroi="${roi.id}"]`);
    if (rh) { rh.setAttribute('x', roi.geo.cx + roi.geo.r - HANDLE_R); rh.setAttribute('y', roi.geo.cy - HANDLE_R); }
  } else {
    const poly = roi.svgG.querySelector('polygon');
    if (poly) poly.setAttribute('points', roi.geo.points.map(p=>`${p.x},${p.y}`).join(' '));
    const cx = roi.geo.points.reduce((s,p)=>s+p.x,0)/roi.geo.points.length;
    const cy = roi.geo.points.reduce((s,p)=>s+p.y,0)/roi.geo.points.length;
    const t = roi.svgG.querySelector('text');
    if (t) { t.setAttribute('x', cx); t.setAttribute('y', cy); }
    // handles
    const hs = lHandles.querySelectorAll(`[data-htype="pv"][data-hroi="${roi.id}"]`);
    hs.forEach((h, i) => {
      if (roi.geo.points[i]) {
        h.setAttribute('cx', roi.geo.points[i].x);
        h.setAttribute('cy', roi.geo.points[i].y);
      }
    });
  }
  // Also sync group members
  if (roi.group) {
    S.rois.filter(r => r.group === roi.group && r.id !== roi.id).forEach(r => {
      syncRoiSvg(r);
    });
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SNAP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function getAllPoints(excludeRoiId) {
  const pts = [];
  S.rois.forEach(roi => {
    if (roi.id === excludeRoiId) return;
    if (roi.type === 'circle') {
      pts.push({ x: roi.geo.cx, y: roi.geo.cy });
    } else {
      roi.geo.points.forEach(p => pts.push({ x: p.x, y: p.y }));
    }
  });
  return pts;
}

function getAllEdges(excludeRoiId) {
  const edges = [];
  S.rois.forEach(roi => {
    if (roi.id === excludeRoiId || roi.type !== 'polygon') return;
    const pts = roi.geo.points;
    pts.forEach((p, i) => {
      edges.push({ a: p, b: pts[(i+1) % pts.length] });
    });
  });
  return edges;
}

function projectOnSegment(p, a, b) {
  const dx = b.x-a.x, dy = b.y-a.y;
  const len2 = dx*dx + dy*dy;
  if (len2 === 0) return null;
  const t = Math.max(0, Math.min(1, ((p.x-a.x)*dx + (p.y-a.y)*dy) / len2));
  return { x: a.x + t*dx, y: a.y + t*dy };
}

function findSnap(x, y, excludeRoiId) {
  let best = null, bestD = SNAP_RADIUS_SVG;

  // Snap to points
  getAllPoints(excludeRoiId).forEach(p => {
    const d = Math.hypot(x-p.x, y-p.y);
    if (d < bestD) { bestD = d; best = { x: p.x, y: p.y }; }
  });

  // Snap to edges
  if (!best) {
    getAllEdges(excludeRoiId).forEach(({ a, b }) => {
      const proj = projectOnSegment({ x, y }, a, b);
      if (!proj) return;
      const d = Math.hypot(x-proj.x, y-proj.y);
      if (d < bestD) { bestD = d; best = proj; }
    });
  }

  return best;
}

function showSnapDot(svgX, svgY) {
  const sp = svgToScreen({ x: svgX, y: svgY });
  snapDot.style.display = 'block';
  snapDot.style.left = sp.x + 'px';
  snapDot.style.top  = sp.y + 'px';
}
function hideSnapDot() { snapDot.style.display = 'none'; }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HANDLE DRAG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function attachDrag(el, roi, moveFn, isGroupMove) {
  let startSvg = null, startGeo = null;

  function begin(cx, cy) {
    startSvg = clientToSvg(cx, cy);
    // Snapshot geometry
    if (isGroupMove && roi.group) {
      const grp = S.rois.filter(r => r.group === roi.group);
      const groupGeos = {};
      grp.forEach(r => {
        if (r.type === 'circle') groupGeos[r.id] = { cx: r.geo.cx, cy: r.geo.cy };
        else groupGeos[r.id] = { points: r.geo.points.map(p => ({...p})) };
      });
      startGeo = { ...JSON.parse(JSON.stringify(roi.geo)), groupGeos };
    } else {
      startGeo = JSON.parse(JSON.stringify(roi.geo));
    }
    S.drag = true; S.pan = null;
  }

  function move(cx, cy) {
    if (!S.drag) return;
    const cur = clientToSvg(cx, cy);
    const dx = cur.x - startSvg.x;
    const dy = cur.y - startSvg.y;
    moveFn(roi, cur, startGeo, dx, dy);
    syncRoiSvg(roi);
  }

  function end() {
    S.drag = false; hideSnapDot();
    // Sync group members visually
    if (isGroupMove && roi.group) {
      S.rois.filter(r => r.group === roi.group).forEach(r => syncRoiSvg(r));
    }
  }

  el.addEventListener('touchstart', e => {
    e.stopPropagation(); e.preventDefault();
    begin(e.touches[0].clientX, e.touches[0].clientY);
  }, { passive: false });
  el.addEventListener('touchmove', e => {
    e.stopPropagation(); e.preventDefault();
    move(e.touches[0].clientX, e.touches[0].clientY);
  }, { passive: false });
  el.addEventListener('touchend', e => { e.stopPropagation(); end(); });

  el.addEventListener('mousedown', e => {
    e.stopPropagation(); e.preventDefault();
    begin(e.clientX, e.clientY);
    const mm = ev => move(ev.clientX, ev.clientY);
    const mu = () => { end(); document.removeEventListener('mousemove', mm); document.removeEventListener('mouseup', mu); };
    document.addEventListener('mousemove', mm);
    document.addEventListener('mouseup', mu);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ZOOM / PAN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let lastPinchDist = 0;
function pxDist(t) { return Math.hypot(t[1].clientX-t[0].clientX, t[1].clientY-t[0].clientY); }

wrap.addEventListener('touchstart', e => {
  if (S.drag) return;
  if (e.touches.length === 2) { lastPinchDist = pxDist(e.touches); e.preventDefault(); return; }
  if (e.touches.length === 1) {
    S.pan = { sx: e.touches[0].clientX, sy: e.touches[0].clientY, vb: {...S.vb}, moved: false };
  }
}, { passive: false });

wrap.addEventListener('touchmove', e => {
  if (S.drag) { e.preventDefault(); return; }
  if (e.touches.length === 2) {
    e.preventDefault();
    const nd = pxDist(e.touches);
    const ratio = lastPinchDist / nd;
    const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
    const before = clientToSvg(cx, cy);
    S.vb.w *= ratio; S.vb.h *= ratio;
    const after = clientToSvg(cx, cy);
    S.vb.x += before.x - after.x; S.vb.y += before.y - after.y;
    applyVB(); lastPinchDist = nd;
    return;
  }
  if (e.touches.length === 1 && S.pan) {
    e.preventDefault();
    const t = e.touches[0];
    const dx = t.clientX - S.pan.sx, dy = t.clientY - S.pan.sy;
    if (Math.hypot(dx, dy) > 5) S.pan.moved = true;
    const rect = wrap.getBoundingClientRect();
    S.vb.x = S.pan.vb.x - dx / rect.width  * S.pan.vb.w;
    S.vb.y = S.pan.vb.y - dy / rect.height * S.pan.vb.h;
    applyVB();
  }
}, { passive: false });

wrap.addEventListener('touchend', e => {
  if (e.touches.length < 2) lastPinchDist = 0;
  if (e.touches.length === 0) S.pan = null;
});

wrap.addEventListener('wheel', e => {
  e.preventDefault();
  const f = e.deltaY > 0 ? 1.1 : 0.9;
  const p = clientToSvg(e.clientX, e.clientY);
  S.vb.w *= f; S.vb.h *= f;
  const p2 = clientToSvg(e.clientX, e.clientY);
  S.vb.x += p.x-p2.x; S.vb.y += p.y-p2.y;
  applyVB();
}, { passive: false });

let mousePan = null;
let _lastTapTime = 0;
wrap.addEventListener('mousedown', e => { if (S.drag) return; mousePan = { sx: e.clientX, sy: e.clientY, vb: {...S.vb}, moved: false }; });
document.addEventListener('mousemove', e => {
  if (!mousePan) return;
  const dx = e.clientX-mousePan.sx, dy = e.clientY-mousePan.sy;
  if (Math.hypot(dx,dy) > 4) mousePan.moved = true;
  const rect = wrap.getBoundingClientRect();
  S.vb.x = mousePan.vb.x - dx/rect.width *mousePan.vb.w;
  S.vb.y = mousePan.vb.y - dy/rect.height*mousePan.vb.h;
  applyVB();
});
document.addEventListener('mouseup', e => {
  if (!mousePan) return;
  const moved = mousePan.moved; mousePan = null;
  if (!moved && Date.now() - _lastTapTime > 300) { /* canvas tap â€” no action needed */ }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ACTIVATE ROI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function activateRoi(id) {
  S.activeId = id;
  rebuildAll();
  updateStatus();
  updatePropPanel();
  updateToolbar();
}

function updatePropPanel() {
  const roi = getRoi(S.activeId);
  if (!roi) { propPanel.classList.remove('open'); return; }
  propPanel.classList.add('open');
  propName.textContent = roi.name;
  const layer = layerById(roi.layer);
  propLayerPill.style.display = 'inline-block';
  propLayerPill.textContent = layer.label;
  propLayerPill.style.color = layer.color;
  propLayerPill.style.borderColor = layer.color;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TOOLBAR & STATUS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateStatus() {
  const total = S.rois.length;
  scTotal.textContent = total;
  roiCount.textContent = total ? `(${total})` : '';
  const roi = getRoi(S.activeId);
  scActive.textContent = roi ? roi.name : 'â€”';
  scLayer.textContent  = roi ? layerById(roi.layer).label : 'â€”';
  scGroup.textContent  = roi?.group || 'â€”';
  scSnap.textContent   = S.snapOn ? 'AN' : 'AUS';
}

function updateToolbar() {
  const roi = getRoi(S.activeId);
  btnAddPt.style.display = (roi && roi.type === 'polygon') ? 'inline-block' : 'none';
  btnMerge.style.display = (roi && roi.type === 'polygon' && !S.mergeMode) ? 'inline-block' : 'none';
  if (S.mergeMode) {
    btnMergeConfirm.style.display = S.mergeIds.length === 2 ? 'inline-block' : 'none';
    btnMerge.style.display = 'none';
  } else {
    btnMergeConfirm.style.display = 'none';
  }
}

function updateEmpty() {
  emptyEl.style.display = S.rois.length ? 'none' : 'flex';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ROI LIST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
btnRois.addEventListener('click', () => {
  closeAllPanels();
  document.getElementById('roi-panel').classList.toggle('open');
  renderRoiList();
});

document.getElementById('roi-panel').addEventListener('click', e => {
  if (e.target === document.getElementById('roi-panel')) closeAllPanels();
});

function renderRoiList() {
  const inner = document.getElementById('roi-panel-inner');
  inner.innerHTML = '';
  if (!S.rois.length) {
    inner.innerHTML = '<div class="pempty">Keine ROIs geladen</div>';
    return;
  }
  S.rois.forEach(roi => {
    const layer = layerById(roi.layer);
    const div = document.createElement('div');
    div.className = 'pitem' + (roi.id === S.activeId ? ' active' : '');

    const dot = document.createElement('div');
    dot.className = 'pdot';
    dot.style.background = layer.color;

    const name = document.createElement('div');
    name.className = 'pname';
    name.textContent = roi.name;

    const badge = document.createElement('span');
    badge.className = 'pbadge';
    badge.textContent = layer.label;
    badge.style.color = layer.color;
    badge.style.borderColor = layer.color + '60';
    badge.style.border = '1px solid';

    const grpBadge = document.createElement('span');
    grpBadge.style.cssText = 'font-family:Share Tech Mono,monospace;font-size:9px;color:var(--dim);white-space:nowrap';
    grpBadge.textContent = roi.group ? 'âŠž'+roi.group : '';

    const del = document.createElement('div');
    del.className = 'pdel';
    del.textContent = 'âœ•';
    del.addEventListener('click', e => { e.stopPropagation(); deleteRoi(roi.id); });
    del.addEventListener('touchend', e => { e.stopPropagation(); e.preventDefault(); deleteRoi(roi.id); });

    div.appendChild(dot); div.appendChild(name); div.appendChild(badge);
    div.appendChild(grpBadge); div.appendChild(del);

    div.addEventListener('click', e => {
      if (e.target === del) return;
      activateRoi(roi.id);
      closeAllPanels();
    });

    // Long press = rename
    let lpt = null;
    div.addEventListener('touchstart', () => {
      lpt = setTimeout(() => openRenameModal(roi.id), 600);
    }, { passive: true });
    ['touchend','touchmove'].forEach(ev => div.addEventListener(ev, () => clearTimeout(lpt)));

    inner.appendChild(div);
  });
}

function deleteRoi(id) {
  const roi = getRoi(id);
  if (!roi) return;
  if (roi.svgG) roi.svgG.remove();
  lHandles.querySelectorAll(`[data-hroi="${id}"]`).forEach(e => e.remove());
  S.rois = S.rois.filter(r => r.id !== id);
  if (S.activeId === id) { S.activeId = S.rois.length ? S.rois[S.rois.length-1].id : null; }
  updateEmpty(); updateStatus(); updateToolbar(); updatePropPanel(); renderRoiList();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SNAP TOGGLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
btnSnap.addEventListener('click', () => {
  S.snapOn = !S.snapOn;
  btnSnap.classList.toggle('on', S.snapOn);
  updateStatus();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ADD POINT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let addPtMode = false;
btnAddPt.addEventListener('click', () => {
  addPtMode = !addPtMode;
  btnAddPt.classList.toggle('on', addPtMode);
  btnAddPt.textContent = addPtMode ? 'âœ“ TIPPEN' : 'ï¼‹ PUNKT';
});

let _lastWrapTap = 0;
wrap.addEventListener('touchend', e => {
  if (e.touches.length !== 0) return;
  if (S.drag) return;
  if (!addPtMode) return;
  const t = e.changedTouches[0];
  if (Date.now() - _lastWrapTap < 300) return;
  _lastWrapTap = Date.now();
  const roi = getRoi(S.activeId);
  if (!roi || roi.type !== 'polygon') return;
  const pt = clientToSvg(t.clientX, t.clientY);
  insertPolyPoint(roi, pt);
  addPtMode = false;
  btnAddPt.classList.remove('on');
  btnAddPt.textContent = 'ï¼‹ PUNKT';
});

function insertPolyPoint(roi, pt) {
  const pts = roi.geo.points;
  let bestD = Infinity, bestIdx = 0;
  pts.forEach((p, i) => {
    const d = pointToSegDist(pt, p, pts[(i+1)%pts.length]);
    if (d < bestD) { bestD = d; bestIdx = i; }
  });
  pts.splice(bestIdx+1, 0, {...pt});
  rebuildRoi(roi);
}

function pointToSegDist(p, a, b) {
  const dx = b.x-a.x, dy = b.y-a.y;
  const len2 = dx*dx+dy*dy;
  if (!len2) return Math.hypot(p.x-a.x, p.y-a.y);
  const t = Math.max(0, Math.min(1, ((p.x-a.x)*dx+(p.y-a.y)*dy)/len2));
  return Math.hypot(p.x-(a.x+t*dx), p.y-(a.y+t*dy));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LAYER ASSIGNMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function openLayerPanel() {
  const panel = document.getElementById('layer-panel');
  panel.innerHTML = '';
  LAYERS.forEach(layer => {
    const item = document.createElement('div');
    item.className = 'layer-item';
    const dot = document.createElement('div');
    dot.className = 'layer-dot';
    dot.style.background = layer.color;
    const name = document.createElement('div');
    name.className = 'layer-name';
    name.textContent = layer.label;
    item.appendChild(dot); item.appendChild(name);
    item.addEventListener('click', () => {
      const roi = getRoi(S.activeId);
      if (roi) { roi.layer = layer.id; rebuildRoi(roi); updateStatus(); updatePropPanel(); renderRoiList(); }
      panel.classList.remove('open');
    });
    panel.appendChild(item);
  });
  panel.classList.toggle('open');
}

// Layer visibility
btnLayers.addEventListener('click', () => {
  closeAllPanels();
  const panel = document.getElementById('layer-vis-panel');
  const inner = document.getElementById('layer-vis-inner');
  inner.innerHTML = '';
  LAYERS.forEach(layer => {
    const visible = S.layerVisibility[layer.id] !== false;
    const div = document.createElement('div');
    div.className = 'pitem';
    div.style.gap = '10px';
    const dot = document.createElement('div');
    dot.className = 'pdot';
    dot.style.background = visible ? layer.color : '#333';
    const name = document.createElement('div');
    name.className = 'pname';
    name.style.color = visible ? '#fff' : 'var(--dim)';
    name.textContent = layer.label;
    const tog = document.createElement('div');
    tog.style.cssText = `font-family:Share Tech Mono,monospace;font-size:10px;color:${visible ? 'var(--cyan)' : 'var(--dim)'}`;
    tog.textContent = visible ? 'SICHTBAR' : 'VERSTECKT';
    div.appendChild(dot); div.appendChild(name); div.appendChild(tog);
    div.addEventListener('click', () => {
      S.layerVisibility[layer.id] = !S.layerVisibility[layer.id];
      S.rois.forEach(r => {
        if (r.layer === layer.id && r.svgG) {
          r.svgG.style.display = S.layerVisibility[layer.id] ? '' : 'none';
        }
      });
      renderLayerVisPanel(inner);
    });
    inner.appendChild(div);
  });
  panel.classList.add('open');
});

function renderLayerVisPanel(inner) {
  inner.innerHTML = '';
  LAYERS.forEach(layer => {
    const visible = S.layerVisibility[layer.id] !== false;
    const div = document.createElement('div');
    div.className = 'pitem';
    div.innerHTML = `
      <div class="pdot" style="background:${visible ? layer.color : '#333'}"></div>
      <div class="pname" style="color:${visible?'#fff':'var(--dim)'}">${layer.label}</div>
      <div style="font-family:Share Tech Mono,monospace;font-size:10px;color:${visible?'var(--cyan)':'var(--dim)'}">${visible?'SICHTBAR':'VERSTECKT'}</div>
    `;
    div.addEventListener('click', () => {
      S.layerVisibility[layer.id] = !visible;
      S.rois.forEach(r => {
        if (r.layer === layer.id && r.svgG) r.svgG.style.display = !visible ? '' : 'none';
      });
      renderLayerVisPanel(inner);
    });
    inner.appendChild(div);
  });
}

document.getElementById('layer-vis-panel').addEventListener('click', e => {
  if (e.target === document.getElementById('layer-vis-panel')) closeAllPanels();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROP PANEL BUTTONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.getElementById('prop-rename-btn').addEventListener('click', () => {
  if (S.activeId) openRenameModal(S.activeId);
});
document.getElementById('prop-group-btn').addEventListener('click', () => {
  if (S.activeId) openGroupModal(S.activeId);
});
document.getElementById('prop-del-btn').addEventListener('click', () => {
  if (S.activeId) deleteRoi(S.activeId);
});

// Rename modal
function openRenameModal(id) {
  const roi = getRoi(id);
  if (!roi) return;
  const m = document.getElementById('m-rename');
  document.getElementById('m-rename-input').value = roi.name;
  document.getElementById('m-rename-ok').dataset.id = id;
  openModal(m);
}
document.getElementById('m-rename-cancel').addEventListener('click', () => closeModal(document.getElementById('m-rename')));
document.getElementById('m-rename-ok').addEventListener('click', () => {
  const id = document.getElementById('m-rename-ok').dataset.id;
  const roi = getRoi(id);
  if (roi) {
    roi.name = document.getElementById('m-rename-input').value.trim() || roi.name;
    rebuildRoi(roi);
    updateStatus(); updatePropPanel(); renderRoiList();
  }
  closeModal(document.getElementById('m-rename'));
});
document.getElementById('m-rename-input').addEventListener('keydown', e => { if (e.key==='Enter') document.getElementById('m-rename-ok').click(); });

// Group modal
function openGroupModal(id) {
  const roi = getRoi(id);
  if (!roi) return;
  const m = document.getElementById('m-group');
  document.getElementById('m-group-input').value = roi.group || '';
  document.getElementById('m-group-ok').dataset.id = id;
  openModal(m);
}
document.getElementById('m-group-cancel').addEventListener('click', () => closeModal(document.getElementById('m-group')));
document.getElementById('m-group-ok').addEventListener('click', () => {
  const id = document.getElementById('m-group-ok').dataset.id;
  const roi = getRoi(id);
  if (roi) {
    roi.group = document.getElementById('m-group-input').value.trim();
    updateStatus(); renderRoiList();
  }
  closeModal(document.getElementById('m-group'));
});
document.getElementById('m-group-input').addEventListener('keydown', e => { if (e.key==='Enter') document.getElementById('m-group-ok').click(); });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MERGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
btnMerge.addEventListener('click', () => {
  S.mergeMode = true;
  S.mergeIds = [S.activeId];
  btnMerge.style.display = 'none';
  btnMergeConfirm.style.display = 'none';
  rebuildAll();
  // Show instruction
  scActive.textContent = 'Zweites Polygon wÃ¤hlen';
});

btnMergeConfirm.addEventListener('click', () => {
  if (S.mergeIds.length < 2) return;
  const r1 = getRoi(S.mergeIds[0]);
  const r2 = getRoi(S.mergeIds[1]);
  if (!r1 || !r2) return;
  const m = document.getElementById('m-merge');
  document.getElementById('m-merge-info').textContent =
    `"${r1.name}" + "${r2.name}" werden zusammengefÃ¼hrt.\nDoppelte/nahe Punkte werden markiert.\nDanach kannst du Punkte lÃ¶schen.`;
  document.getElementById('m-merge-name').value = r1.name;
  openModal(m);
});

document.getElementById('m-merge-cancel').addEventListener('click', () => {
  S.mergeMode = false; S.mergeIds = [];
  closeModal(document.getElementById('m-merge'));
  rebuildAll(); updateToolbar(); updateStatus();
});

document.getElementById('m-merge-ok').addEventListener('click', () => {
  const r1 = getRoi(S.mergeIds[0]);
  const r2 = getRoi(S.mergeIds[1]);
  if (!r1 || !r2) return;
  const name = document.getElementById('m-merge-name').value.trim() || r1.name;
  performMerge(r1, r2, name);
  closeModal(document.getElementById('m-merge'));
  S.mergeMode = false; S.mergeIds = [];
  rebuildAll(); updateToolbar(); updateStatus(); renderRoiList();
});

function performMerge(r1, r2, name) {
  // Simple merge: concatenate points, remove near-duplicates
  const allPts = [...r1.geo.points, ...r2.geo.points];
  const merged = [allPts[0]];
  allPts.slice(1).forEach(p => {
    const prev = merged[merged.length-1];
    if (Math.hypot(p.x-prev.x, p.y-prev.y) > 5) merged.push(p);
  });
  r1.name = name;
  r1.geo.points = merged;
  // Remove r2
  if (r2.svgG) r2.svgG.remove();
  lHandles.querySelectorAll(`[data-hroi="${r2.id}"]`).forEach(e => e.remove());
  S.rois = S.rois.filter(r => r.id !== r2.id);
  S.activeId = r1.id;
  rebuildRoi(r1);
  updatePropPanel(); renderRoiList();
}

// Merge selection: when merge mode active, selecting from list picks second ROI
const _origActivate = activateRoi;
function activateRoi(id) {
  if (S.mergeMode && id !== S.mergeIds[0]) {
    const roi = getRoi(id);
    if (roi && roi.type === 'polygon') {
      S.mergeIds[1] = id;
      rebuildAll();
      updateToolbar();
      updateStatus();
      btnMergeConfirm.style.display = 'inline-block';
      return;
    }
  }
  S.activeId = id;
  rebuildAll();
  updateStatus();
  updatePropPanel();
  updateToolbar();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JSON EXPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function r2(v) { return Math.round(v*100)/100; }
function edgeAngle(a,b) {
  let d = Math.atan2(b.y-a.y, b.x-a.x)*180/Math.PI;
  if (d<0) d+=360;
  return Math.round(d*10)/10;
}

btnExport.addEventListener('click', () => {
  const data = {
    meta: {
      tool: 'WorldCompositor v1.0',
      exportedAt: new Date().toISOString(),
      coordinateOrigin: 'top-left',
      roiCount: S.rois.length,
    },
    rois: S.rois.map(roi => {
      const base = {
        id: roi.id,
        name: roi.name,
        type: roi.type,
        layer: roi.layer,
        group: roi.group || null,
        isCalibrationROI: false,
      };
      if (roi.type === 'circle') {
        return {
          ...base,
          units: { cx: r2(roi.geo.cx), cy: r2(roi.geo.cy), r: r2(roi.geo.r) },
          pixels: null,
        };
      } else {
        const pts = roi.geo.points;
        const edges = pts.map((p,i) => {
          const n = pts[(i+1)%pts.length];
          const lenU = Math.hypot(n.x-p.x, n.y-p.y);
          return { from:i, to:(i+1)%pts.length, lengthUnits:r2(lenU), angleDeg:edgeAngle(p,n) };
        });
        return {
          ...base,
          units: { points: pts.map(p => ({ x:r2(p.x), y:r2(p.y) })) },
          pixels: null,
          edges,
        };
      }
    }),
  };

  const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'worldmap_composite_' + new Date().toISOString().slice(0,10) + '.json';
  a.click();
  URL.revokeObjectURL(url);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
applyVB();
updateStatus();
updateToolbar();
document.addEventListener('contextmenu', e => e.preventDefault());
</script>

</body>
</html>
