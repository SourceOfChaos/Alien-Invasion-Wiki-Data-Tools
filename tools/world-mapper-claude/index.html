<!DOCTYPE html>

<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>WorldMapper</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Outfit:wght@300;400;500;600&display=swap');

:root {
â€“bg:       #0d0f14;
â€“surf:     #141720;
â€“surf2:    #1c2030;
â€“border:   #2a3048;
â€“accent:   #e8ff47;
â€“cyan:     #47ffe8;
â€“danger:   #ff4757;
â€“text:     #c8d0e8;
â€“dim:      #5a6280;
â€“handle-r: 14px;
}

- { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }

body {
background: var(â€“bg);
color: var(â€“text);
font-family: â€˜Outfitâ€™, sans-serif;
height: 100dvh;
display: flex;
flex-direction: column;
overflow: hidden;
user-select: none;
-webkit-user-select: none;
}

/* â”€â”€ HEADER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
header {
display: flex;
align-items: center;
justify-content: space-between;
padding: 8px 12px;
background: var(â€“surf);
border-bottom: 1px solid var(â€“border);
flex-shrink: 0;
gap: 8px;
z-index: 10;
}
.logo {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 12px;
color: var(â€“accent);
letter-spacing: 2px;
}
.hdr-btns { display: flex; gap: 6px; }

/* â”€â”€ TOOLBAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.toolbar {
display: flex;
align-items: center;
gap: 5px;
padding: 6px 12px;
background: var(â€“surf);
border-bottom: 1px solid var(â€“border);
flex-shrink: 0;
overflow-x: auto;
scrollbar-width: none;
}
.toolbar::-webkit-scrollbar { display: none; }
.tsep { width: 1px; height: 18px; background: var(â€“border); flex-shrink: 0; }

/* â”€â”€ BUTTONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.btn {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 10px;
letter-spacing: 1px;
padding: 6px 10px;
border: 1px solid var(â€“border);
background: var(â€“surf2);
color: var(â€“text);
border-radius: 4px;
cursor: pointer;
white-space: nowrap;
flex-shrink: 0;
transition: opacity .1s;
}
.btn:active { opacity: .7; }
.btn.on    { background: var(â€“accent); color: #0d0f14; border-color: var(â€“accent); }
.btn.cyan  { border-color: var(â€“cyan); color: var(â€“cyan); }
.btn.cyan.on { background: var(â€“cyan); color: #0d0f14; }
.btn.red   { border-color: var(â€“danger); color: var(â€“danger); }
.btn.file  { border-color: var(â€“cyan); color: var(â€“cyan); }
.btn.exp   { border-color: var(â€“accent); color: var(â€“accent); }
.btn.imp   { border-color: var(â€“dim); color: var(â€“dim); }
.btn[disabled] { opacity: .3; pointer-events: none; }

/* â”€â”€ STATUS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.statusbar {
display: flex; gap: 10px;
padding: 4px 12px;
background: var(â€“bg);
border-bottom: 1px solid var(â€“border);
flex-shrink: 0;
overflow-x: auto;
scrollbar-width: none;
}
.statusbar::-webkit-scrollbar { display: none; }
.chip {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 10px;
color: var(â€“dim);
white-space: nowrap;
}
.chip b { color: var(â€“cyan); font-weight: 400; }
.chip.warn b { color: var(â€“danger); }

/* â”€â”€ CANVAS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#wrap {
flex: 1;
position: relative;
overflow: hidden;
background: #0a0c10;
touch-action: none;
}
#svg {
position: absolute;
inset: 0;
width: 100%; height: 100%;
overflow: visible;
}

/* â”€â”€ ROI OVERLAY PANEL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#roi-panel {
display: none;
position: fixed;
inset: 0;
z-index: 50;
background: #00000055;
align-items: flex-start;
justify-content: flex-start;
padding-top: 110px;
}
#roi-panel.open { display: flex; }
#roi-panel-inner {
background: #1c2030f5;
border: 1px solid var(â€“border);
border-radius: 0 0 8px 8px;
width: 100%;
max-height: 55vh;
overflow-y: auto;
scrollbar-width: thin;
}
.rpitem {
display: flex; align-items: center; gap: 10px;
padding: 11px 14px;
border-bottom: 1px solid var(â€“border);
cursor: pointer;
}
.rpitem:last-child { border-bottom: none; }
.rpitem.active { background: #e8ff4710; }
.rpitem:active { background: var(â€“surf2); }
.rpdot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
.rpname {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 12px; flex: 1;
color: #ffffff;
overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.rpitem.active .rpname { color: var(â€“accent); }
.rptype { font-family: â€˜Share Tech Monoâ€™, monospace; font-size: 10px; color: var(â€“dim); flex-shrink: 0; }
.rpdel  { font-size: 15px; color: var(â€“dim); padding: 2px 6px; flex-shrink: 0; }
.rpempty {
padding: 16px 14px;
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 11px; color: var(â€“dim); text-align: center;
}

/* â”€â”€ EMPTY STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#empty {
position: absolute; inset: 0;
display: flex; flex-direction: column;
align-items: center; justify-content: center;
gap: 10px; pointer-events: none;
}
.empty-ico { font-size: 36px; opacity: .25; }
.empty-txt {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 11px; color: var(â€“dim);
text-align: center; line-height: 1.9; letter-spacing: 1px;
}

/* â”€â”€ MODALS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.modal-bg {
display: none; position: fixed; inset: 0;
background: #000b; z-index: 200;
align-items: center; justify-content: center; padding: 20px;
}
.modal-bg.open { display: flex; }
.modal {
background: var(â€“surf);
border: 1px solid var(â€“border);
border-radius: 10px;
padding: 20px; width: 100%; max-width: 320px;
}
.modal-title {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 12px; color: var(â€“accent);
letter-spacing: 2px; margin-bottom: 14px;
}
.flabel {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 10px; color: var(â€“dim);
letter-spacing: 1px; margin-bottom: 5px;
}
.finput {
width: 100%;
background: var(â€“bg); border: 1px solid var(â€“border);
color: var(â€“text);
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 14px; padding: 9px 11px; border-radius: 4px; outline: none;
}
.finput:focus { border-color: var(â€“cyan); }
.fhint { font-size: 11px; color: var(â€“dim); margin-top: 5px; line-height: 1.5; }
.mbtns { display: flex; gap: 8px; justify-content: flex-end; margin-top: 14px; }

/* â”€â”€ IMPORT WARNING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.import-warn {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 10px;
color: var(â€“danger);
margin-top: 10px;
line-height: 1.6;
display: none;
}
.import-warn.show { display: block; }
</style>

</head>
<body>

<header>
  <div class="logo">â—ˆ WORLDMAPPER</div>
  <div class="hdr-btns">
    <button class="btn imp" id="btn-import">â¬† JSON</button>
    <button class="btn file" id="btn-load">ğŸ“‚ BILD</button>
    <button class="btn exp"  id="btn-export" disabled>â¬‡ JSON</button>
  </div>
</header>

<div class="toolbar">
  <button class="btn cyan" id="btn-calib"   disabled>âŠ™ KALIB</button>
  <div class="tsep"></div>
  <button class="btn" id="btn-circle"  disabled>â—‹ KREIS</button>
  <button class="btn" id="btn-poly"    disabled>â¬¡ POLY</button>
  <button class="btn" id="btn-addpt"   style="display:none">ï¼‹ PUNKT</button>
  <button class="btn" id="btn-closepoly" style="display:none">âœ“ SCHLIESSEN</button>
  <div class="tsep"></div>
  <button class="btn" id="btn-rois">â˜° ROIs <span id="roi-count"></span></button>
</div>

<div class="statusbar">
  <div class="chip" id="sc-img">IMG <b>â€”</b></div>
  <div class="chip" id="sc-scale">SCALE <b>â€”</b></div>
  <div class="chip" id="sc-active">AKTIV <b>â€”</b></div>
  <div class="chip" id="sc-mode">MODE <b>WÃ„HLEN</b></div>
</div>

<div id="wrap">
  <svg id="svg" xmlns="http://www.w3.org/2000/svg">
    <g id="l-img"></g>
    <g id="l-roi"></g>
    <g id="l-handles"></g>
    <g id="l-polyprev"></g>
  </svg>
  <div id="empty">
    <div class="empty-ico">ğŸ—º</div>
    <div class="empty-txt">BILD LADEN<br>â†’ KALIBRIEREN<br>â†’ ROIs ERFASSEN<br>â†’ JSON EXPORT</div>
  </div>
</div>

<!-- ROI Panel -->

<div id="roi-panel">
  <div id="roi-panel-inner"></div>
</div>

<!-- File inputs -->

<input type="file" id="finput" accept="image/*" style="display:none">
<input type="file" id="jinput" accept=".json,application/json" style="display:none">

<!-- Modal: Name -->

<div class="modal-bg" id="m-name">
  <div class="modal">
    <div class="modal-title" id="m-name-title">NEUES ROI</div>
    <div class="flabel">NAME</div>
    <input class="finput" id="m-name-input" type="text" autocomplete="off" placeholder="z.B. Kustov_Raum">
    <div class="mbtns">
      <button class="btn" id="m-name-cancel">ABBRUCH</button>
      <button class="btn on" id="m-name-ok">OK</button>
    </div>
  </div>
</div>

<!-- Modal: Calib units -->

<div class="modal-bg" id="m-calib">
  <div class="modal">
    <div class="modal-title">KALIBRIERUNG</div>
    <div class="flabel">RADIUS IN SPIELEINHEITEN</div>
    <input class="finput" id="m-calib-input" type="number" step="0.01" min="0.001" placeholder="z.B. 50">
    <div class="fhint">Der Radius des Kalibrierungskreises entspricht diesem Wert.<br>Alle ROIs werden danach umgerechnet.</div>
    <div class="mbtns">
      <button class="btn" id="m-calib-cancel">ABBRUCH</button>
      <button class="btn cyan" id="m-calib-ok">KALIBRIEREN</button>
    </div>
  </div>
</div>

<!-- Modal: Rename -->

<div class="modal-bg" id="m-rename">
  <div class="modal">
    <div class="modal-title">UMBENENNEN</div>
    <div class="flabel">NEUER NAME</div>
    <input class="finput" id="m-rename-input" type="text" autocomplete="off">
    <div class="mbtns">
      <button class="btn" id="m-rename-cancel">ABBRUCH</button>
      <button class="btn on" id="m-rename-ok">SPEICHERN</button>
    </div>
  </div>
</div>

<!-- Modal: Import -->

<div class="modal-bg" id="m-import">
  <div class="modal">
    <div class="modal-title">â¬† JSON IMPORTIEREN</div>
    <div class="fhint" style="margin-bottom:10px;">
      LÃ¤dt ROIs und Kalibrierung aus einer vorherigen Session.<br>
      Das Bild muss separat geladen werden (gleiche AuflÃ¶sung empfohlen).
    </div>
    <div class="flabel">VERHALTEN</div>
    <select class="finput" id="m-import-mode" style="cursor:pointer;">
      <option value="replace">Bestehende ROIs ersetzen</option>
      <option value="merge">ROIs zusammenfÃ¼hren (merge)</option>
    </select>
    <div class="import-warn" id="m-import-warn">
      âš  Kein Bild geladen â€” Import trotzdem mÃ¶glich,<br>aber ROIs erst nach Bildladen sichtbar.
    </div>
    <div class="mbtns">
      <button class="btn" id="m-import-cancel">ABBRUCH</button>
      <button class="btn cyan" id="m-import-ok">ğŸ“‚ DATEI WÃ„HLEN</button>
    </div>
  </div>
</div>

<script>
'use strict';
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONSTANTS & STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const NS = 'http://www.w3.org/2000/svg';
const HANDLE_HIT   = 22;
const POLY_CLOSE_HIT = 26;

const PALETTE = [
  '#e8ff47','#ff6b81','#a29bfe','#fd79a8',
  '#55efc4','#fdcb6e','#74b9ff','#ff7675'
];

let S = {
  img: null,
  vb: { x:0, y:0, w:0, h:0 },
  unitPerPx: null,
  calibId: null,
  rois: [],
  activeId: null,
  mode: 'select',
  polyPts: [],
  polyName: '',
  drag: null,
  pan: null,
  roiPanelOpen: false,
  _roiSeq: 0,
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DOM REFS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const wrap            = document.getElementById('wrap');
const svgEl           = document.getElementById('svg');
const lImg            = document.getElementById('l-img');
const lRoi            = document.getElementById('l-roi');
const lHandles        = document.getElementById('l-handles');
const lPoly           = document.getElementById('l-polyprev');
const emptyEl         = document.getElementById('empty');
const roiPanel        = document.getElementById('roi-panel');
const roiPanelInner   = document.getElementById('roi-panel-inner');
const fileInput       = document.getElementById('finput');
const jsonInput       = document.getElementById('jinput');

const btnLoad         = document.getElementById('btn-load');
const btnExport       = document.getElementById('btn-export');
const btnImport       = document.getElementById('btn-import');
const btnCalib        = document.getElementById('btn-calib');
const btnCircle       = document.getElementById('btn-circle');
const btnPoly         = document.getElementById('btn-poly');
const btnAddPt        = document.getElementById('btn-addpt');
const btnClosePoly    = document.getElementById('btn-closepoly');
const btnRois         = document.getElementById('btn-rois');
const roiCount        = document.getElementById('roi-count');

const scImg    = document.getElementById('sc-img');
const scScale  = document.getElementById('sc-scale');
const scActive = document.getElementById('sc-active');
const scMode   = document.getElementById('sc-mode');

const mName       = document.getElementById('m-name');
const mNameTitle  = document.getElementById('m-name-title');
const mNameInput  = document.getElementById('m-name-input');
const mNameCancel = document.getElementById('m-name-cancel');
const mNameOk     = document.getElementById('m-name-ok');

const mCalib       = document.getElementById('m-calib');
const mCalibInput  = document.getElementById('m-calib-input');
const mCalibCancel = document.getElementById('m-calib-cancel');
const mCalibOk     = document.getElementById('m-calib-ok');

const mRename       = document.getElementById('m-rename');
const mRenameInput  = document.getElementById('m-rename-input');
const mRenameCancel = document.getElementById('m-rename-cancel');
const mRenameOk     = document.getElementById('m-rename-ok');

const mImport       = document.getElementById('m-import');
const mImportMode   = document.getElementById('m-import-mode');
const mImportWarn   = document.getElementById('m-import-warn');
const mImportCancel = document.getElementById('m-import-cancel');
const mImportOk     = document.getElementById('m-import-ok');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UTILS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function uid() { return 'r' + (++S._roiSeq); }

function mkSvg(tag, attrs) {
  const el = document.createElementNS(NS, tag);
  for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, v);
  return el;
}

function clientToSvg(cx, cy) {
  const rect = wrap.getBoundingClientRect();
  return {
    x: S.vb.x + (cx - rect.left) / rect.width  * S.vb.w,
    y: S.vb.y + (cy - rect.top)  / rect.height * S.vb.h,
  };
}

function svgDistToScreen(d) {
  const rect = wrap.getBoundingClientRect();
  return d / S.vb.w * rect.width;
}

function applyVB() {
  svgEl.setAttribute('viewBox', `${S.vb.x} ${S.vb.y} ${S.vb.w} ${S.vb.h}`);
}

function clampVB() {
  if (!S.img) return;
  const m = S.vb.w * 0.5;
  S.vb.x = Math.max(-m, Math.min(S.img.w + m - S.vb.w, S.vb.x));
  S.vb.y = Math.max(-m, Math.min(S.img.h + m - S.vb.h, S.vb.y));
}

function roiColor(roi) {
  if (roi.isCalib) return '#47ffe8';
  const idx = S.rois.filter(r => !r.isCalib).indexOf(roi);
  return PALETTE[Math.max(0, idx) % PALETTE.length];
}

function getRoi(id) { return S.rois.find(r => r.id === id); }

function openModal(m) {
  m.classList.add('open');
  setTimeout(() => m.querySelector('input,select')?.focus(), 80);
}
function closeModal(m) { m.classList.remove('open'); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATUS & TOOLBAR UPDATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateStatus() {
  if (S.img) {
    scImg.querySelector('b').textContent = `${S.img.w}Ã—${S.img.h}`;
    scImg.classList.remove('warn');
  } else {
    scImg.querySelector('b').textContent = 'â€”';
  }
  if (S.unitPerPx) {
    scScale.querySelector('b').textContent = S.unitPerPx.toFixed(4) + 'u/px';
    scScale.classList.remove('warn');
  } else {
    scScale.querySelector('b').textContent = 'â€”';
    scScale.classList.add('warn');
  }
  const ar = getRoi(S.activeId);
  scActive.querySelector('b').textContent = ar ? ar.name : 'â€”';
  scMode.querySelector('b').textContent = S.mode.toUpperCase();
  roiCount.textContent = S.rois.length ? `(${S.rois.length})` : '';
}

function updateToolbar() {
  [btnCalib, btnCircle, btnPoly].forEach(b => b.classList.remove('on'));
  if (S.mode === 'calib')  btnCalib.classList.add('on');
  if (S.mode === 'circle') btnCircle.classList.add('on');
  if (S.mode === 'poly' || S.mode === 'addpt') btnPoly.classList.add('on');

  const inPoly = S.mode === 'poly';
  btnClosePoly.style.display = inPoly && S.polyPts.length >= 3 ? 'inline-block' : 'none';

  const ar = getRoi(S.activeId);
  btnAddPt.style.display =
    (S.mode === 'select' || S.mode === 'addpt') && ar && ar.type === 'polygon'
      ? 'inline-block' : 'none';
  btnAddPt.classList.toggle('on', S.mode === 'addpt');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// IMAGE LOAD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
btnLoad.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const url = URL.createObjectURL(file);
  const img = new Image();
  img.onload = () => {
    S.img = { w: img.width, h: img.height, src: url };
    // Only reset rois if none imported yet
    if (!S._importedWithoutImage) {
      S.rois = []; S.activeId = null; S.unitPerPx = null;
      S.calibId = null; S._roiSeq = 0;
    }
    S._importedWithoutImage = false;
    S.polyPts = []; S.polyName = '';
    lImg.innerHTML = ''; lRoi.innerHTML = '';
    lHandles.innerHTML = ''; lPoly.innerHTML = '';

    const imgNode = mkSvg('image', {
      href: url, x: 0, y: 0,
      width: img.width, height: img.height,
      preserveAspectRatio: 'none',
    });
    lImg.appendChild(imgNode);

    const cw = wrap.clientWidth, ch = wrap.clientHeight;
    const sc = Math.min(cw / img.width, ch / img.height) * 0.92;
    S.vb = {
      x: -(cw / sc - img.width) / 2,
      y: -(ch / sc - img.height) / 2,
      w: cw / sc, h: ch / sc,
    };
    applyVB();
    emptyEl.style.display = 'none';
    btnCalib.disabled = false;
    btnCircle.disabled = false;
    btnPoly.disabled = false;
    btnExport.disabled = false;

    // Rebuild any imported ROIs
    S.rois.forEach(r => buildRoiSvg(r));
    if (S.rois.length && !S.activeId) S.activeId = S.rois[S.rois.length-1].id;

    setMode(S.rois.length ? 'select' : 'calib');
    updateStatus(); updateToolbar(); renderRoiList();
  };
  img.src = url;
  fileInput.value = '';
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MODE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function setMode(m) {
  if (S.mode === 'poly' && m !== 'poly' && m !== 'addpt') cancelPoly();
  if (S.mode === 'addpt' && m !== 'addpt') S.addPtMode = false;
  S.mode = m;
  updateStatus(); updateToolbar();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ZOOM / PAN  â€” proven stable implementation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let panState = null, pinchState = null;
let _lastTapTime = 0;

wrap.addEventListener('touchstart', e => {
  if (S.drag) return;
  if (e.touches.length === 2) {
    panState = null;
    // Snapshot the FULL initial state â€” never mutate this during the gesture
    pinchState = {
      dist: Math.hypot(
        e.touches[1].clientX - e.touches[0].clientX,
        e.touches[1].clientY - e.touches[0].clientY
      ),
      cx: (e.touches[0].clientX + e.touches[1].clientX) / 2,
      cy: (e.touches[0].clientY + e.touches[1].clientY) / 2,
      vb: { ...S.vb },   // frozen reference â€” never touched again
    };
    e.preventDefault();
    return;
  }
  if (e.touches.length === 1) {
    pinchState = null;
    panState = { sx: e.touches[0].clientX, sy: e.touches[0].clientY, vb: { ...S.vb }, moved: false };
  }
}, { passive: false });

wrap.addEventListener('touchmove', e => {
  if (S.drag) { e.preventDefault(); return; }
  e.preventDefault();

  if (e.touches.length === 2 && pinchState) {
    const newDist = Math.hypot(
      e.touches[1].clientX - e.touches[0].clientX,
      e.touches[1].clientY - e.touches[0].clientY
    );
    const newCx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    const newCy = (e.touches[0].clientY + e.touches[1].clientY) / 2;

    // Scale factor relative to INITIAL pinch distance â€” no drift
    const scale = pinchState.dist / newDist;

    const rect = wrap.getBoundingClientRect();
    // SVG point under the initial pinch center (fixed pivot)
    const pivotX = pinchState.vb.x + (pinchState.cx - rect.left) / rect.width  * pinchState.vb.w;
    const pivotY = pinchState.vb.y + (pinchState.cy - rect.top)  / rect.height * pinchState.vb.h;

    const newW = pinchState.vb.w * scale;
    const newH = pinchState.vb.h * scale;

    // Pan offset: finger midpoint moved since gesture start
    const panDx = (newCx - pinchState.cx) / rect.width  * newW;
    const panDy = (newCy - pinchState.cy) / rect.height * newH;

    S.vb.w = newW;
    S.vb.h = newH;
    S.vb.x = pivotX - (pinchState.cx - rect.left) / rect.width  * newW - panDx;
    S.vb.y = pivotY - (pinchState.cy - rect.top)  / rect.height * newH - panDy;

    clampVB(); applyVB();
    return;
  }

  if (e.touches.length === 1 && panState) {
    const dx = e.touches[0].clientX - panState.sx;
    const dy = e.touches[0].clientY - panState.sy;
    if (Math.hypot(dx, dy) > 6) panState.moved = true;
    const rect = wrap.getBoundingClientRect();
    S.vb.x = panState.vb.x - dx / rect.width  * panState.vb.w;
    S.vb.y = panState.vb.y - dy / rect.height * panState.vb.h;
    clampVB(); applyVB();
  }
}, { passive: false });

wrap.addEventListener('touchend', e => {
  if (e.touches.length < 2) pinchState = null;
  if (e.touches.length === 0) {
    const moved = panState?.moved;
    panState = null;
    if (!moved && !S.drag) {
      _lastTapTime = Date.now();
      handleTap(e.changedTouches[0]);
    }
  }
});

wrap.addEventListener('touchcancel', () => { pinchState = null; panState = null; });

// â”€â”€ Mouse wheel zoom â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
wrap.addEventListener('wheel', e => {
  e.preventDefault();
  if (!S.img) return;
  const f = e.deltaY > 0 ? 1.1 : 0.9;
  const p = clientToSvg(e.clientX, e.clientY);
  S.vb.w *= f; S.vb.h *= f;
  const p2 = clientToSvg(e.clientX, e.clientY);
  S.vb.x += p.x - p2.x; S.vb.y += p.y - p2.y;
  clampVB(); applyVB();
}, { passive: false });

// â”€â”€ Mouse pan â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _mousePan = null;
wrap.addEventListener('mousedown', e => {
  if (S.drag) return;
  _mousePan = { sx: e.clientX, sy: e.clientY, vb: { ...S.vb }, moved: false };
});
document.addEventListener('mousemove', e => {
  if (!_mousePan) return;
  const dx = e.clientX - _mousePan.sx;
  const dy = e.clientY - _mousePan.sy;
  if (Math.hypot(dx, dy) > 4) _mousePan.moved = true;
  const rect = wrap.getBoundingClientRect();
  S.vb.x = _mousePan.vb.x - dx / rect.width  * _mousePan.vb.w;
  S.vb.y = _mousePan.vb.y - dy / rect.height * _mousePan.vb.h;
  clampVB(); applyVB();
});
document.addEventListener('mouseup', e => {
  if (!_mousePan) return;
  const moved = _mousePan.moved;
  _mousePan = null;
  if (!moved && Date.now() - _lastTapTime > 300) {
    handleTap({ clientX: e.clientX, clientY: e.clientY });
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAP HANDLER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function handleTap(t) {
  if (!S.img) return;
  const pt = clientToSvg(t.clientX, t.clientY);

  if (S.mode === 'calib') {
    mNameTitle.textContent = 'âŠ™ KALIBRIERUNGS-KREIS';
    mNameInput.value = 'Fangradius';
    openModal(mName);
    mNameOk._action = () => {
      const name = mNameInput.value.trim() || 'Fangradius';
      closeModal(mName);
      addCircleRoi(name, pt, true);
      openModal(mCalib);
    };
    return;
  }

  if (S.mode === 'circle') {
    mNameTitle.textContent = 'â—‹ NEUER KREIS';
    mNameInput.value = '';
    openModal(mName);
    mNameOk._action = () => {
      const name = mNameInput.value.trim() || ('Kreis_' + S._roiSeq);
      closeModal(mName);
      addCircleRoi(name, pt, false);
      setMode('select');
    };
    return;
  }

  if (S.mode === 'poly') {
    if (S.polyPts.length >= 3) {
      const fp = S.polyPts[0];
      const screenDist = svgDistToScreen(Math.hypot(pt.x - fp.x, pt.y - fp.y));
      if (screenDist < POLY_CLOSE_HIT) { closePoly(); return; }
    }
    S.polyPts.push({ ...pt });
    renderPolyPreview();
    updateToolbar();
    return;
  }

  if (S.mode === 'addpt') {
    const roi = getRoi(S.activeId);
    if (!roi || roi.type !== 'polygon') { setMode('select'); return; }
    insertPolyPoint(roi, pt);
    setMode('select');
    return;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MODAL LOGIC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
mNameCancel.addEventListener('click', () => { closeModal(mName); setMode('select'); });
mNameOk.addEventListener('click', () => { if (mNameOk._action) mNameOk._action(); });
mNameInput.addEventListener('keydown', e => { if (e.key === 'Enter') mNameOk.click(); });

mCalibCancel.addEventListener('click', () => closeModal(mCalib));
mCalibOk.addEventListener('click', () => {
  const v = parseFloat(mCalibInput.value);
  if (!v || v <= 0) return;
  const roi = getRoi(S.calibId);
  if (roi) S.unitPerPx = v / roi.geo.r;
  closeModal(mCalib);
  setMode('select');
  updateStatus();
});
mCalibInput.addEventListener('keydown', e => { if (e.key === 'Enter') mCalibOk.click(); });

mRenameCancel.addEventListener('click', () => closeModal(mRename));
mRenameOk.addEventListener('click', () => {
  const roi = getRoi(mRenameOk._roiId);
  if (roi) { roi.name = mRenameInput.value.trim() || roi.name; }
  closeModal(mRename); renderRoiList(); updateStatus();
});
mRenameInput.addEventListener('keydown', e => { if (e.key === 'Enter') mRenameOk.click(); });

// â”€â”€ Import modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
btnImport.addEventListener('click', () => {
  mImportWarn.classList.toggle('show', !S.img);
  openModal(mImport);
});
mImportCancel.addEventListener('click', () => closeModal(mImport));
mImportOk.addEventListener('click', () => {
  closeModal(mImport);
  jsonInput.click();
});

jsonInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    try {
      const data = JSON.parse(ev.target.result);
      importJson(data, mImportMode.value);
    } catch(err) {
      alert('JSON konnte nicht gelesen werden:\n' + err.message);
    }
  };
  reader.readAsText(file);
  jsonInput.value = '';
});

function importJson(data, mergeMode) {
  if (!data.rois || !Array.isArray(data.rois)) {
    alert('UngÃ¼ltiges Format: keine ROI-Liste gefunden.');
    return;
  }

  if (mergeMode === 'replace') {
    // Clear existing
    S.rois.forEach(r => { if (r.svgG) r.svgG.remove(); });
    lHandles.innerHTML = '';
    S.rois = [];
    S.calibId = null;
    S.activeId = null;
    S._roiSeq = 0;
  }

  // Restore calibration
  if (data.meta?.unitPerPx && data.meta.calibrated) {
    S.unitPerPx = data.meta.unitPerPx;
  }

  let lastId = null;
  for (const rd of data.rois) {
    const id = uid();
    if (rd.isCalibrationROI && mergeMode === 'replace') S.calibId = id;

    let roi;
    if (rd.type === 'circle') {
      const g = rd.pixels;
      roi = {
        id, name: rd.name || 'ROI',
        type: 'circle', isCalib: !!rd.isCalibrationROI,
        geo: { cx: g.cx, cy: g.cy, r: g.r },
        svgG: null,
      };
    } else if (rd.type === 'polygon') {
      const g = rd.pixels;
      roi = {
        id, name: rd.name || 'ROI',
        type: 'polygon', isCalib: false,
        geo: { points: g.points.map(p => ({ x: p.x, y: p.y })) },
        svgG: null,
      };
    } else continue;

    S.rois.push(roi);
    if (S.img) buildRoiSvg(roi);
    lastId = id;
  }

  if (!S.img) {
    // Mark that we imported without image so image-load won't wipe rois
    S._importedWithoutImage = true;
    // Enable toolbar buttons so user can load image next
    btnCalib.disabled = false;
    btnCircle.disabled = false;
    btnPoly.disabled = false;
    btnExport.disabled = false;
  }

  if (lastId) activateRoi(lastId);
  renderRoiList(); updateStatus(); updateToolbar();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TOOLBAR BUTTONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
btnCalib.addEventListener('click', () => {
  if (!S.img) return;
  if (S.calibId) { openModal(mCalib); return; }
  setMode('calib');
});

btnCircle.addEventListener('click', () => { if (S.img) setMode('circle'); });

btnPoly.addEventListener('click', () => {
  if (!S.img) return;
  if (S.mode === 'poly') return;
  S.polyPts = [];
  mNameTitle.textContent = 'â¬¡ NEUES POLYGON';
  mNameInput.value = '';
  openModal(mName);
  mNameOk._action = () => {
    S.polyName = mNameInput.value.trim() || ('Poly_' + (S._roiSeq + 1));
    closeModal(mName);
    setMode('poly');
  };
});

btnClosePoly.addEventListener('click', () => closePoly());

btnAddPt.addEventListener('click', () => {
  if (S.mode === 'addpt') setMode('select');
  else setMode('addpt');
});

btnRois.addEventListener('click', () => {
  S.roiPanelOpen = !S.roiPanelOpen;
  roiPanel.classList.toggle('open', S.roiPanelOpen);
});
roiPanel.addEventListener('click', e => {
  if (e.target === roiPanel) { S.roiPanelOpen = false; roiPanel.classList.remove('open'); }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ROI CREATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function addCircleRoi(name, center, isCalib) {
  const defR = S.img ? Math.min(S.img.w, S.img.h) * 0.06 : 50;
  const roi = {
    id: uid(), name, type: 'circle', isCalib,
    geo: { cx: center.x, cy: center.y, r: defR },
    svgG: null,
  };
  S.rois.push(roi);
  if (isCalib) {
    if (S.calibId) removeRoi(S.calibId);
    S.calibId = roi.id;
  }
  buildRoiSvg(roi);
  activateRoi(roi.id);
  renderRoiList(); updateStatus(); updateToolbar();
  return roi;
}

function addPolyRoi(name, points) {
  const roi = {
    id: uid(), name, type: 'polygon', isCalib: false,
    geo: { points: points.map(p => ({ ...p })) },
    svgG: null,
  };
  S.rois.push(roi);
  buildRoiSvg(roi);
  activateRoi(roi.id);
  renderRoiList(); updateStatus(); updateToolbar();
  return roi;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POLYGON PREVIEW & CLOSE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderPolyPreview() {
  lPoly.innerHTML = '';
  const pts = S.polyPts;
  if (!pts.length) return;
  const color = '#e8ff47';
  if (pts.length >= 2) {
    const d = 'M' + pts.map(p => `${p.x},${p.y}`).join('L');
    lPoly.appendChild(mkSvg('path', {
      d, fill: 'none', stroke: color,
      'stroke-width': 1.5, 'stroke-dasharray': '7 4',
      'pointer-events': 'none',
    }));
  }
  pts.forEach(p => {
    lPoly.appendChild(mkSvg('circle', {
      cx: p.x, cy: p.y, r: 9,
      fill: color, stroke: '#0d0f14', 'stroke-width': 2,
      'pointer-events': 'none',
    }));
  });
  if (pts.length >= 3) {
    lPoly.appendChild(mkSvg('circle', {
      cx: pts[0].x, cy: pts[0].y, r: 16,
      fill: 'none', stroke: color,
      'stroke-width': 1.5, 'stroke-dasharray': '4 3',
      opacity: '0.5', 'pointer-events': 'none',
    }));
  }
}

function closePoly() {
  if (S.polyPts.length < 3) return;
  addPolyRoi(S.polyName || ('Poly_' + S._roiSeq), S.polyPts);
  S.polyPts = []; S.polyName = '';
  lPoly.innerHTML = '';
  setMode('select');
}

function cancelPoly() {
  S.polyPts = []; S.polyName = '';
  lPoly.innerHTML = '';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BUILD / REBUILD ROI SVG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildRoiSvg(roi) {
  if (roi.svgG) roi.svgG.remove();
  const isActive = roi.id === S.activeId;
  const color = roiColor(roi);
  const g = document.createElementNS(NS, 'g');
  g.dataset.roiId = roi.id;

  if (roi.type === 'circle') {
    g.appendChild(mkSvg('circle', {
      cx: roi.geo.cx, cy: roi.geo.cy, r: roi.geo.r,
      fill: color + (isActive ? '55' : '28'),
      stroke: color,
      'stroke-width': isActive ? 2 : 0.8,
      opacity: isActive ? 1 : 0.5,
      'pointer-events': 'none',
    }));
  } else {
    g.appendChild(mkSvg('polygon', {
      points: roi.geo.points.map(p => `${p.x},${p.y}`).join(' '),
      fill: color + (isActive ? '55' : '28'),
      stroke: color,
      'stroke-width': isActive ? 2 : 0.8,
      opacity: isActive ? 1 : 0.5,
      'pointer-events': 'none',
    }));
  }

  lRoi.appendChild(g);
  roi.svgG = g;
  buildHandles(roi);
}

function rebuildRoi(roi) { buildRoiSvg(roi); }

function buildHandles(roi) {
  lHandles.querySelectorAll(`[data-hroi="${roi.id}"]`).forEach(el => el.remove());
  if (roi.id !== S.activeId) return;
  const color = roiColor(roi);

  if (roi.type === 'circle') {
    const ch = mkSvg('circle', {
      cx: roi.geo.cx, cy: roi.geo.cy,
      r: HANDLE_HIT / 2,
      fill: color, stroke: '#0d0f14', 'stroke-width': 2,
      cursor: 'move',
    });
    ch.dataset.htype = 'cc'; ch.dataset.hroi = roi.id;
    lHandles.appendChild(ch);
    attachHandleDrag(ch, roi, moveCenterHandle);

    const rh = mkSvg('rect', {
      x: roi.geo.cx + roi.geo.r - HANDLE_HIT/2,
      y: roi.geo.cy - HANDLE_HIT/2,
      width: HANDLE_HIT, height: HANDLE_HIT,
      fill: color, stroke: '#0d0f14', 'stroke-width': 2,
      rx: 3, cursor: 'ew-resize',
    });
    rh.dataset.htype = 'cr'; rh.dataset.hroi = roi.id;
    lHandles.appendChild(rh);
    attachHandleDrag(rh, roi, moveRadiusHandle);

  } else {
    roi.geo.points.forEach((p, i) => {
      const h = mkSvg('circle', {
        cx: p.x, cy: p.y, r: HANDLE_HIT / 2,
        fill: color, stroke: '#0d0f14', 'stroke-width': 2,
        cursor: 'move',
      });
      h.dataset.htype = 'pv'; h.dataset.hroiIdx = i; h.dataset.hroi = roi.id;
      lHandles.appendChild(h);
      attachHandleDrag(h, roi, (roi, svg, startGeo, dx, dy) => {
        roi.geo.points[i].x = startGeo.points[i].x + dx;
        roi.geo.points[i].y = startGeo.points[i].y + dy;
      });

      let lpt = null;
      h.addEventListener('touchstart', () => {
        lpt = setTimeout(() => {
          if (roi.geo.points.length > 3) {
            roi.geo.points.splice(i, 1);
            rebuildRoi(roi);
          }
        }, 600);
      }, { passive: true });
      ['touchend','touchmove'].forEach(ev => h.addEventListener(ev, () => clearTimeout(lpt)));
    });
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HANDLE MOVE FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function moveCenterHandle(roi, svgPt, startGeo, dx, dy) {
  roi.geo.cx = startGeo.cx + dx;
  roi.geo.cy = startGeo.cy + dy;
}
function moveRadiusHandle(roi, svgPt, startGeo, dx, dy) {
  roi.geo.r = Math.max(4, Math.hypot(svgPt.x - roi.geo.cx, svgPt.y - roi.geo.cy));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HANDLE DRAG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function attachHandleDrag(el, roi, moveFn) {
  let startSvg = null, startGeo = null;

  function begin(cx, cy) {
    startSvg = clientToSvg(cx, cy);
    startGeo = JSON.parse(JSON.stringify(roi.geo));
    S.drag = true;
    _pan = null; _pinch = null;
  }
  function move(cx, cy) {
    if (!S.drag || !startSvg) return;
    const cur = clientToSvg(cx, cy);
    moveFn(roi, cur, startGeo, cur.x - startSvg.x, cur.y - startSvg.y);
    syncRoiSvg(roi);
  }
  function end() { S.drag = false; startSvg = null; startGeo = null; }

  el.addEventListener('touchstart', e => {
    e.stopPropagation(); e.preventDefault();
    begin(e.touches[0].clientX, e.touches[0].clientY);
  }, { passive: false });
  el.addEventListener('touchmove', e => {
    e.stopPropagation(); e.preventDefault();
    move(e.touches[0].clientX, e.touches[0].clientY);
  }, { passive: false });
  el.addEventListener('touchend', e => { e.stopPropagation(); end(); });

  el.addEventListener('mousedown', e => {
    e.stopPropagation(); e.preventDefault();
    begin(e.clientX, e.clientY);
    const mm = ev => move(ev.clientX, ev.clientY);
    const mu = () => { end(); document.removeEventListener('mousemove', mm); document.removeEventListener('mouseup', mu); };
    document.addEventListener('mousemove', mm);
    document.addEventListener('mouseup', mu);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SYNC ROI SVG (during drag)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function syncRoiSvg(roi) {
  if (!roi.svgG) return;
  if (roi.type === 'circle') {
    const c = roi.svgG.querySelector('circle');
    if (c) { c.setAttribute('cx', roi.geo.cx); c.setAttribute('cy', roi.geo.cy); c.setAttribute('r', roi.geo.r); }
    const ch = lHandles.querySelector(`[data-htype="cc"][data-hroi="${roi.id}"]`);
    if (ch) { ch.setAttribute('cx', roi.geo.cx); ch.setAttribute('cy', roi.geo.cy); }
    const rh = lHandles.querySelector(`[data-htype="cr"][data-hroi="${roi.id}"]`);
    if (rh) { rh.setAttribute('x', roi.geo.cx + roi.geo.r - HANDLE_HIT/2); rh.setAttribute('y', roi.geo.cy - HANDLE_HIT/2); }
  } else {
    const poly = roi.svgG.querySelector('polygon');
    if (poly) poly.setAttribute('points', roi.geo.points.map(p => `${p.x},${p.y}`).join(' '));
    lHandles.querySelectorAll(`[data-htype="pv"][data-hroi="${roi.id}"]`).forEach((h, i) => {
      if (roi.geo.points[i]) { h.setAttribute('cx', roi.geo.points[i].x); h.setAttribute('cy', roi.geo.points[i].y); }
    });
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INSERT POLYGON POINT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function insertPolyPoint(roi, pt) {
  const pts = roi.geo.points;
  let bestDist = Infinity, bestIdx = 0;
  for (let i = 0; i < pts.length; i++) {
    const a = pts[i], b = pts[(i+1) % pts.length];
    const d = pointToSegmentDist(pt, a, b);
    if (d < bestDist) { bestDist = d; bestIdx = i; }
  }
  pts.splice(bestIdx + 1, 0, { ...pt });
  rebuildRoi(roi);
}

function pointToSegmentDist(p, a, b) {
  const dx = b.x-a.x, dy = b.y-a.y;
  const len2 = dx*dx+dy*dy;
  if (len2 === 0) return Math.hypot(p.x-a.x, p.y-a.y);
  const t = Math.max(0, Math.min(1, ((p.x-a.x)*dx+(p.y-a.y)*dy)/len2));
  return Math.hypot(p.x-(a.x+t*dx), p.y-(a.y+t*dy));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ACTIVATE ROI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function activateRoi(id) {
  S.activeId = id;
  S.rois.forEach(r => rebuildRoi(r));
  updateStatus(); updateToolbar();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REMOVE ROI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function removeRoi(id) {
  const roi = getRoi(id);
  if (!roi) return;
  if (roi.svgG) roi.svgG.remove();
  lHandles.querySelectorAll(`[data-hroi="${id}"]`).forEach(el => el.remove());
  S.rois = S.rois.filter(r => r.id !== id);
  if (S.calibId === id) S.calibId = null;
  if (S.activeId === id) S.activeId = S.rois.length ? S.rois[S.rois.length-1].id : null;
  if (S.activeId) activateRoi(S.activeId);
  renderRoiList(); updateStatus(); updateToolbar();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ROI LIST PANEL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderRoiList() {
  roiPanelInner.innerHTML = '';
  if (!S.rois.length) {
    roiPanelInner.innerHTML = '<div class="rpempty">Keine ROIs vorhanden</div>';
    roiCount.textContent = '';
    return;
  }
  roiCount.textContent = `(${S.rois.length})`;
  S.rois.forEach(roi => {
    const color = roiColor(roi);
    const div = document.createElement('div');
    div.className = 'rpitem' + (roi.id === S.activeId ? ' active' : '');

    const dot = document.createElement('div');
    dot.className = 'rpdot';
    dot.style.background = color;

    const name = document.createElement('div');
    name.className = 'rpname';
    name.textContent = roi.name;

    const type = document.createElement('div');
    type.className = 'rptype';
    type.textContent = roi.isCalib ? 'âŠ™' : roi.type === 'circle' ? 'â—‹' : 'â¬¡';

    const del = document.createElement('div');
    del.className = 'rpdel';
    del.textContent = 'âœ•';
    del.addEventListener('click', e => { e.stopPropagation(); removeRoi(roi.id); });
    del.addEventListener('touchend', e => { e.stopPropagation(); e.preventDefault(); removeRoi(roi.id); });

    let lpt = null;
    div.addEventListener('touchstart', () => {
      lpt = setTimeout(() => {
        mRenameInput.value = roi.name;
        mRenameOk._roiId = roi.id;
        openModal(mRename);
      }, 600);
    }, { passive: true });
    ['touchend','touchmove'].forEach(ev => div.addEventListener(ev, () => clearTimeout(lpt)));

    div.addEventListener('click', e => {
      if (e.target === del) return;
      activateRoi(roi.id);
      S.roiPanelOpen = false;
      roiPanel.classList.remove('open');
    });

    div.appendChild(dot);
    div.appendChild(name);
    div.appendChild(type);
    div.appendChild(del);
    roiPanelInner.appendChild(div);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JSON EXPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function edgeAngle(a, b) {
  let deg = Math.atan2(b.y-a.y, b.x-a.x) * 180 / Math.PI;
  if (deg < 0) deg += 360;
  return Math.round(deg * 10) / 10;
}
function r2(v) { return Math.round(v * 100) / 100; }

btnExport.addEventListener('click', () => {
  const u = S.unitPerPx || 1;
  const cal = !!S.unitPerPx;
  const data = {
    meta: {
      tool: 'WorldMapper v2.0',
      exportedAt: new Date().toISOString(),
      imageSize: S.img ? { width: S.img.w, height: S.img.h } : null,
      calibrated: cal,
      unitPerPx: S.unitPerPx ?? null,
      coordinateOrigin: 'top-left',
    },
    rois: S.rois.map(roi => {
      const base = { id: roi.id, name: roi.name, type: roi.type, isCalibrationROI: !!roi.isCalib };
      if (roi.type === 'circle') {
        const g = roi.geo;
        return {
          ...base,
          pixels: { cx: r2(g.cx), cy: r2(g.cy), r: r2(g.r) },
          units: cal ? { cx: r2(g.cx*u), cy: r2(g.cy*u), r: r2(g.r*u) } : null,
        };
      } else {
        const pts = roi.geo.points;
        const edges = pts.map((p, i) => {
          const n = pts[(i+1) % pts.length];
          const lenPx = Math.hypot(n.x-p.x, n.y-p.y);
          return {
            from: i, to: (i+1) % pts.length,
            lengthPx: r2(lenPx),
            lengthUnits: cal ? r2(lenPx*u) : null,
            angleDeg: edgeAngle(p, n),
          };
        });
        return {
          ...base,
          pixels: { points: pts.map(p => ({ x: r2(p.x), y: r2(p.y) })) },
          units: cal ? { points: pts.map(p => ({ x: r2(p.x*u), y: r2(p.y*u) })) } : null,
          edges,
        };
      }
    }),
  };

  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'worldmap_' + new Date().toISOString().slice(0,10) + '.json';
  a.click();
  URL.revokeObjectURL(url);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PREVENT CONTEXT MENU
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.addEventListener('contextmenu', e => e.preventDefault());

// INIT
updateStatus(); updateToolbar();
</script>

</body>
</html>
