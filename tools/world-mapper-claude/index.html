<!DOCTYPE html>

<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>WorldMapper</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Outfit:wght@300;400;500;600&display=swap');

:root {
â€“bg: #0d0f14;
â€“surface: #141720;
â€“surface2: #1c2030;
â€“border: #2a3048;
â€“accent: #e8ff47;
â€“accent2: #47ffe8;
â€“danger: #ff4757;
â€“text: #c8d0e8;
â€“text-dim: #5a6280;
â€“roi-active: #e8ff47;
â€“roi-inactive: #47ffe840;
â€“calib: #47ffe8;
}

- { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }

body {
background: var(â€“bg);
color: var(â€“text);
font-family: â€˜Outfitâ€™, sans-serif;
height: 100dvh;
display: flex;
flex-direction: column;
overflow: hidden;
user-select: none;
}

/* â”€â”€ HEADER â”€â”€ */
header {
display: flex;
align-items: center;
justify-content: space-between;
padding: 10px 14px;
background: var(â€“surface);
border-bottom: 1px solid var(â€“border);
gap: 8px;
flex-shrink: 0;
z-index: 10;
}

.logo {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 13px;
color: var(â€“accent);
letter-spacing: 2px;
white-space: nowrap;
}

.header-actions {
display: flex;
gap: 6px;
align-items: center;
}

.btn {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 11px;
letter-spacing: 1px;
padding: 7px 12px;
border: 1px solid var(â€“border);
background: var(â€“surface2);
color: var(â€“text);
border-radius: 4px;
cursor: pointer;
transition: all 0.15s;
white-space: nowrap;
}
.btn:active { transform: scale(0.96); }
.btn.accent { background: var(â€“accent); color: #0d0f14; border-color: var(â€“accent); font-weight: 600; }
.btn.calib { border-color: var(â€“calib); color: var(â€“calib); }
.btn.danger { border-color: var(â€“danger); color: var(â€“danger); }
.btn.sm { padding: 5px 8px; font-size: 10px; }

/* â”€â”€ TOOLBAR â”€â”€ */
.toolbar {
display: flex;
align-items: center;
gap: 6px;
padding: 8px 14px;
background: var(â€“surface);
border-bottom: 1px solid var(â€“border);
flex-shrink: 0;
overflow-x: auto;
scrollbar-width: none;
}
.toolbar::-webkit-scrollbar { display: none; }

.tool-btn {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 10px;
letter-spacing: 1px;
padding: 6px 10px;
border: 1px solid var(â€“border);
background: var(â€“surface2);
color: var(â€“text-dim);
border-radius: 4px;
cursor: pointer;
transition: all 0.15s;
white-space: nowrap;
flex-shrink: 0;
}
.tool-btn.active {
background: var(â€“accent);
color: #0d0f14;
border-color: var(â€“accent);
color: #0d0f14;
}
.tool-btn.calib-btn.active {
background: var(â€“calib);
border-color: var(â€“calib);
color: #0d0f14;
}
.tool-sep { width: 1px; height: 20px; background: var(â€“border); flex-shrink: 0; }

/* â”€â”€ STATUS BAR â”€â”€ */
.status-bar {
display: flex;
align-items: center;
gap: 12px;
padding: 5px 14px;
background: var(â€“bg);
border-bottom: 1px solid var(â€“border);
flex-shrink: 0;
overflow-x: auto;
scrollbar-width: none;
}
.status-bar::-webkit-scrollbar { display: none; }
.status-chip {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 10px;
color: var(â€“text-dim);
white-space: nowrap;
display: flex;
align-items: center;
gap: 4px;
}
.status-chip span { color: var(â€“accent2); }
.status-chip.warn span { color: var(â€“danger); }

/* â”€â”€ CANVAS AREA â”€â”€ */
#canvas-wrap {
flex: 1;
overflow: hidden;
position: relative;
background: repeating-linear-gradient(
45deg,
#0d0f14 0px, #0d0f14 10px,
#111318 10px, #111318 20px
);
touch-action: none;
}

#svg-root {
position: absolute;
top: 0; left: 0;
width: 100%; height: 100%;
overflow: visible;
}

/* â”€â”€ ROI DROPDOWN â”€â”€ */
.roi-dropdown-wrap {
position: absolute;
bottom: 14px;
left: 14px;
right: 14px;
z-index: 20;
}

.roi-dropdown-header {
display: flex;
align-items: center;
justify-content: space-between;
background: var(â€“surface);
border: 1px solid var(â€“border);
border-radius: 6px;
padding: 10px 14px;
cursor: pointer;
gap: 8px;
}
.roi-dropdown-header.open {
border-bottom-left-radius: 0;
border-bottom-right-radius: 0;
border-color: var(â€“accent);
}

.roi-dropdown-label {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 11px;
color: var(â€“text-dim);
letter-spacing: 1px;
flex-shrink: 0;
}
.roi-active-name {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 12px;
color: var(â€“accent);
flex: 1;
text-overflow: ellipsis;
overflow: hidden;
white-space: nowrap;
}
.roi-chevron {
font-size: 10px;
color: var(â€“text-dim);
transition: transform 0.2s;
flex-shrink: 0;
}
.roi-chevron.open { transform: rotate(180deg); }

.roi-list {
display: none;
background: var(â€“surface);
border: 1px solid var(â€“accent);
border-top: none;
border-bottom-left-radius: 6px;
border-bottom-right-radius: 6px;
max-height: 220px;
overflow-y: auto;
scrollbar-width: thin;
scrollbar-color: var(â€“border) transparent;
}
.roi-list.open { display: block; }

.roi-item {
display: flex;
align-items: center;
padding: 10px 14px;
gap: 10px;
border-bottom: 1px solid var(â€“border);
cursor: pointer;
transition: background 0.1s;
}
.roi-item:last-child { border-bottom: none; }
.roi-item:active { background: var(â€“surface2); }
.roi-item.active { background: #e8ff4710; }

.roi-dot {
width: 8px; height: 8px;
border-radius: 50%;
flex-shrink: 0;
}
.roi-item-name {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 12px;
color: var(â€“text);
flex: 1;
text-overflow: ellipsis;
overflow: hidden;
white-space: nowrap;
}
.roi-item.active .roi-item-name { color: var(â€“accent); }
.roi-item-type {
font-size: 10px;
color: var(â€“text-dim);
font-family: â€˜Share Tech Monoâ€™, monospace;
flex-shrink: 0;
}
.roi-del {
font-size: 14px;
color: var(â€“text-dim);
padding: 2px 4px;
flex-shrink: 0;
}
.roi-del:active { color: var(â€“danger); }

/* â”€â”€ MODAL â”€â”€ */
.modal-overlay {
display: none;
position: fixed;
inset: 0;
background: #000a;
z-index: 100;
align-items: center;
justify-content: center;
padding: 20px;
}
.modal-overlay.open { display: flex; }

.modal {
background: var(â€“surface);
border: 1px solid var(â€“border);
border-radius: 10px;
padding: 20px;
width: 100%;
max-width: 340px;
}

.modal-title {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 13px;
color: var(â€“accent);
letter-spacing: 2px;
margin-bottom: 16px;
}

.field-group { margin-bottom: 14px; }
.field-label {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 10px;
color: var(â€“text-dim);
letter-spacing: 1px;
margin-bottom: 5px;
}
.field-input {
width: 100%;
background: var(â€“bg);
border: 1px solid var(â€“border);
color: var(â€“text);
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 14px;
padding: 10px 12px;
border-radius: 4px;
outline: none;
}
.field-input:focus { border-color: var(â€“accent2); }

.modal-actions {
display: flex;
gap: 8px;
justify-content: flex-end;
margin-top: 16px;
}

/* â”€â”€ CALIB INFO â”€â”€ */
.calib-hint {
font-size: 11px;
color: var(â€“text-dim);
line-height: 1.5;
margin-top: 6px;
}

/* â”€â”€ EMPTY STATE â”€â”€ */
.empty-state {
position: absolute;
inset: 0;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
gap: 12px;
pointer-events: none;
}
.empty-icon { font-size: 40px; opacity: 0.3; }
.empty-text {
font-family: â€˜Share Tech Monoâ€™, monospace;
font-size: 12px;
color: var(â€“text-dim);
text-align: center;
letter-spacing: 1px;
line-height: 1.8;
}

/* â”€â”€ SVG STYLES (inline) â”€â”€ */
.roi-polygon-preview {
fill: none;
stroke: var(â€“accent);
stroke-width: 1.5;
stroke-dasharray: 6 4;
pointer-events: none;
}

/* Polygon point indicator during creation */
.poly-point-indicator {
fill: var(â€“accent);
stroke: #0d0f14;
stroke-width: 2;
pointer-events: none;
}
</style>

</head>
<body>

<!-- HEADER -->

<header>
  <div class="logo">â—ˆ WORLDMAPPER</div>
  <div class="header-actions">
    <button class="btn calib sm" id="btn-load-img">ðŸ“‚ BILD</button>
    <button class="btn sm" id="btn-export" disabled>â¬‡ JSON</button>
  </div>
</header>

<!-- TOOLBAR -->

<div class="toolbar">
  <button class="tool-btn calib-btn" id="tool-calib" disabled>âŠ™ KALIBRIERUNG</button>
  <div class="tool-sep"></div>
  <button class="tool-btn" id="tool-circle" disabled>â—‹ KREIS</button>
  <button class="tool-btn" id="tool-polygon" disabled>â¬¡ POLYGON</button>
  <div class="tool-sep"></div>
  <button class="tool-btn" id="tool-select">â†– SELECT</button>
</div>

<!-- STATUS BAR -->

<div class="status-bar">
  <div class="status-chip" id="status-img">IMG <span>â€”</span></div>
  <div class="status-chip" id="status-calib">SCALE <span>â€”</span></div>
  <div class="status-chip" id="status-coords">XY <span>â€”</span></div>
  <div class="status-chip" id="status-mode">MODE <span>SELECT</span></div>
</div>

<!-- CANVAS -->

<div id="canvas-wrap">
  <svg id="svg-root" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <pattern id="grid" width="50" height="50" patternUnits="userSpaceOnUse">
        <path d="M 50 0 L 0 0 0 50" fill="none" stroke="#1c2030" stroke-width="0.5"/>
      </pattern>
    </defs>
    <!-- layers -->
    <g id="layer-bg"></g>
    <g id="layer-image"></g>
    <g id="layer-rois"></g>
    <g id="layer-handles"></g>
    <g id="layer-poly-preview"></g>
  </svg>

  <div class="empty-state" id="empty-state">
    <div class="empty-icon">ðŸ—º</div>
    <div class="empty-text">BILD LADEN â†’ KALIBRIEREN<br>â†’ ROIs SETZEN â†’ EXPORT</div>
  </div>
</div>

<!-- ROI DROPDOWN -->

<div class="roi-dropdown-wrap">
  <div class="roi-dropdown-header" id="roi-dropdown-header">
    <span class="roi-dropdown-label">ROI</span>
    <span class="roi-active-name" id="roi-active-label">â€” kein ROI â€”</span>
    <span class="roi-chevron" id="roi-chevron">â–¼</span>
  </div>
  <div class="roi-list" id="roi-list"></div>
</div>

<!-- HIDDEN FILE INPUT -->

<input type="file" id="file-input" accept="image/*" style="display:none">

<!-- MODAL: ROI Name -->

<div class="modal-overlay" id="modal-name">
  <div class="modal">
    <div class="modal-title" id="modal-name-title">NEUES ROI</div>
    <div class="field-group">
      <div class="field-label">NAME</div>
      <input class="field-input" id="input-roi-name" type="text" placeholder="z.B. Kustov_Raum" autocomplete="off">
    </div>
    <div class="modal-actions">
      <button class="btn" id="modal-name-cancel">ABBRUCH</button>
      <button class="btn accent" id="modal-name-ok">ERSTELLEN</button>
    </div>
  </div>
</div>

<!-- MODAL: Kalibrierung -->

<div class="modal-overlay" id="modal-calib">
  <div class="modal">
    <div class="modal-title">KALIBRIERUNG</div>
    <div class="field-group">
      <div class="field-label">REALE GRÃ–SSE IN SPIELEINHEITEN</div>
      <input class="field-input" id="input-calib-units" type="number" step="0.1" min="0.01" placeholder="z.B. 50">
      <div class="calib-hint">Kreis-Radius entspricht diesem Wert.<br>Alle ROIs werden danach umgerechnet.</div>
    </div>
    <div class="modal-actions">
      <button class="btn" id="modal-calib-cancel">ABBRUCH</button>
      <button class="btn calib" id="modal-calib-ok">KALIBRIEREN</button>
    </div>
  </div>
</div>

<!-- MODAL: Rename -->

<div class="modal-overlay" id="modal-rename">
  <div class="modal">
    <div class="modal-title">ROI UMBENENNEN</div>
    <div class="field-group">
      <div class="field-label">NEUER NAME</div>
      <input class="field-input" id="input-rename" type="text" autocomplete="off">
    </div>
    <div class="modal-actions">
      <button class="btn" id="modal-rename-cancel">ABBRUCH</button>
      <button class="btn accent" id="modal-rename-ok">SPEICHERN</button>
    </div>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const state = {
  image: null,          // { width, height, src }
  viewBox: { x: 0, y: 0, w: 0, h: 0 },
  unitPerPx: null,
  calibROI: null,       // roi id of calibration circle
  rois: [],             // { id, name, type, geometry, svgEl, handleEls }
  activeROI: null,
  mode: 'select',       // 'select' | 'calib' | 'circle' | 'polygon'
  polyPoints: [],       // during polygon creation
  polyPreviewLine: null,
  drag: null,           // { type, roiId, handleIdx, startX, startY, ... }
  pan: { active: false, startX: 0, startY: 0, vbStart: null },
  pinch: null,
  isDragging: false,    // true while a handle drag is happening
};

let roiCounter = 0;
const svgNS = 'http://www.w3.org/2000/svg';

// â”€â”€â”€ DOM refs â”€â”€â”€
const canvasWrap = document.getElementById('canvas-wrap');
const svgRoot = document.getElementById('svg-root');
const layerBG = document.getElementById('layer-bg');
const layerImage = document.getElementById('layer-image');
const layerROIs = document.getElementById('layer-rois');
const layerHandles = document.getElementById('layer-handles');
const layerPolyPreview = document.getElementById('layer-poly-preview');
const emptyState = document.getElementById('empty-state');

const fileInput = document.getElementById('file-input');
const btnLoadImg = document.getElementById('btn-load-img');
const btnExport = document.getElementById('btn-export');

const toolCalib = document.getElementById('tool-calib');
const toolCircle = document.getElementById('tool-circle');
const toolPolygon = document.getElementById('tool-polygon');
const toolSelect = document.getElementById('tool-select');

const statusImg = document.getElementById('status-img');
const statusCalib = document.getElementById('status-calib');
const statusCoords = document.getElementById('status-coords');
const statusMode = document.getElementById('status-mode');

const roiDropdownHeader = document.getElementById('roi-dropdown-header');
const roiDropdownHeaderEl = document.querySelector('.roi-dropdown-header');
const roiList = document.getElementById('roi-list');
const roiActiveLabel = document.getElementById('roi-active-label');
const roiChevron = document.getElementById('roi-chevron');

// modals
const modalName = document.getElementById('modal-name');
const modalNameTitle = document.getElementById('modal-name-title');
const inputRoiName = document.getElementById('input-roi-name');
const modalNameCancel = document.getElementById('modal-name-cancel');
const modalNameOk = document.getElementById('modal-name-ok');

const modalCalib = document.getElementById('modal-calib');
const inputCalibUnits = document.getElementById('input-calib-units');
const modalCalibCancel = document.getElementById('modal-calib-cancel');
const modalCalibOk = document.getElementById('modal-calib-ok');

const modalRename = document.getElementById('modal-rename');
const inputRename = document.getElementById('input-rename');
const modalRenameCancel = document.getElementById('modal-rename-cancel');
const modalRenameOk = document.getElementById('modal-rename-ok');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function uid() { return 'roi_' + (++roiCounter); }

function svgEl(tag, attrs) {
  const el = document.createElementNS(svgNS, tag);
  for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, v);
  return el;
}

function clientToSVG(clientX, clientY) {
  const rect = canvasWrap.getBoundingClientRect();
  const ratioX = state.viewBox.w / rect.width;
  const ratioY = state.viewBox.h / rect.height;
  return {
    x: state.viewBox.x + (clientX - rect.left) * ratioX,
    y: state.viewBox.y + (clientY - rect.top) * ratioY,
  };
}

function updateSVGViewBox() {
  const vb = state.viewBox;
  svgRoot.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);
}

function clampViewBox() {
  const vb = state.viewBox;
  const img = state.image;
  if (!img) return;
  const margin = vb.w * 0.5;
  vb.x = Math.max(-margin, Math.min(img.width + margin - vb.w, vb.x));
  vb.y = Math.max(-margin, Math.min(img.height + margin - vb.h, vb.y));
}

function setMode(m) {
  // Cancel polygon creation if switching away
  if (state.mode === 'polygon' && m !== 'polygon') cancelPolygon();

  state.mode = m;
  [toolCalib, toolCircle, toolPolygon, toolSelect].forEach(b => b.classList.remove('active'));
  if (m === 'calib') toolCalib.classList.add('active');
  else if (m === 'circle') toolCircle.classList.add('active');
  else if (m === 'polygon') toolPolygon.classList.add('active');
  else toolSelect.classList.add('active');
  statusMode.querySelector('span').textContent = m.toUpperCase();
}

function setActiveROI(id) {
  state.activeROI = id;
  renderAllROIs();
  updateDropdownLabel();
}

function updateDropdownLabel() {
  const roi = state.rois.find(r => r.id === state.activeROI);
  roiActiveLabel.textContent = roi ? roi.name : 'â€” kein ROI â€”';
}

function updateStatus() {
  if (state.image) {
    statusImg.querySelector('span').textContent =
      `${state.image.width}Ã—${state.image.height}`;
    statusImg.classList.remove('warn');
  } else {
    statusImg.querySelector('span').textContent = 'â€”';
    statusImg.classList.add('warn');
  }
  if (state.unitPerPx) {
    statusCalib.querySelector('span').textContent =
      `${state.unitPerPx.toFixed(4)}u/px`;
    statusCalib.classList.remove('warn');
  } else {
    statusCalib.querySelector('span').textContent = 'â€”';
    statusCalib.classList.add('warn');
  }
}

function roiColor(roi) {
  if (roi.id === state.calibROI) return '#47ffe8';
  const palette = ['#e8ff47','#ff6b81','#a29bfe','#fd79a8','#55efc4','#fdcb6e'];
  const idx = state.rois.indexOf(roi) % palette.length;
  return palette[idx];
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// IMAGE LOADING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
btnLoadImg.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const url = URL.createObjectURL(file);
  const img = new Image();
  img.onload = () => {
    state.image = { width: img.width, height: img.height, src: url };
    // Clear existing
    layerImage.innerHTML = '';
    layerROIs.innerHTML = '';
    layerHandles.innerHTML = '';
    layerPolyPreview.innerHTML = '';
    state.rois = [];
    state.activeROI = null;
    state.unitPerPx = null;
    state.calibROI = null;
    roiCounter = 0;

    // Embed image
    const imgEl = svgEl('image', {
      href: url,
      x: 0, y: 0,
      width: img.width,
      height: img.height,
      preserveAspectRatio: 'none',
    });
    layerImage.appendChild(imgEl);

    // Set viewBox
    const cw = canvasWrap.clientWidth;
    const ch = canvasWrap.clientHeight;
    const scale = Math.min(cw / img.width, ch / img.height) * 0.9;
    state.viewBox = {
      x: -(cw / scale - img.width) / 2,
      y: -(ch / scale - img.height) / 2,
      w: cw / scale,
      h: ch / scale,
    };
    updateSVGViewBox();

    emptyState.style.display = 'none';
    toolCalib.disabled = false;
    toolCircle.disabled = false;
    toolPolygon.disabled = false;
    btnExport.disabled = false;
    setMode('calib');
    updateStatus();
    renderROIList();
  };
  img.src = url;
  fileInput.value = '';
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ZOOM / PAN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let lastPinchDist = 0;
let lastPinchCenter = null;

function getTouchDist(t) {
  const dx = t[1].clientX - t[0].clientX;
  const dy = t[1].clientY - t[0].clientY;
  return Math.sqrt(dx*dx + dy*dy);
}

canvasWrap.addEventListener('touchstart', e => {
  if (state.isDragging) return;

  if (e.touches.length === 2) {
    // Pinch start
    state.pan.active = false;
    lastPinchDist = getTouchDist(e.touches);
    lastPinchCenter = {
      x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
      y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
    };
    e.preventDefault();
    return;
  }

  if (e.touches.length === 1) {
    const t = e.touches[0];
    // If over a handle â†’ don't pan
    if (e.target.dataset.handle) return;
    if (e.target.dataset.roiClick) return;

    state.pan = {
      active: true,
      startX: t.clientX,
      startY: t.clientY,
      vbStart: { ...state.viewBox },
    };
  }
}, { passive: false });

canvasWrap.addEventListener('touchmove', e => {
  if (state.isDragging) {
    e.preventDefault();
    return;
  }

  if (e.touches.length === 2) {
    e.preventDefault();
    const newDist = getTouchDist(e.touches);
    const center = {
      x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
      y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
    };
    const ratio = lastPinchDist / newDist;
    const svgCenter = clientToSVG(center.x, center.y);

    state.viewBox.w *= ratio;
    state.viewBox.h *= ratio;

    // Keep center stable
    const newSvgCenter = clientToSVG(center.x, center.y);
    state.viewBox.x += svgCenter.x - newSvgCenter.x;
    state.viewBox.y += svgCenter.y - newSvgCenter.y;

    clampViewBox();
    updateSVGViewBox();
    lastPinchDist = newDist;
    lastPinchCenter = center;
    return;
  }

  if (e.touches.length === 1 && state.pan.active) {
    e.preventDefault();
    const t = e.touches[0];
    const rect = canvasWrap.getBoundingClientRect();
    const ratioX = state.viewBox.w / rect.width;
    const ratioY = state.viewBox.h / rect.height;
    state.viewBox.x = state.pan.vbStart.x - (t.clientX - state.pan.startX) * ratioX;
    state.viewBox.y = state.pan.vbStart.y - (t.clientY - state.pan.startY) * ratioY;
    clampViewBox();
    updateSVGViewBox();
  }
}, { passive: false });

canvasWrap.addEventListener('touchend', e => {
  if (e.touches.length < 2) lastPinchDist = 0;
  if (e.touches.length === 0) state.pan.active = false;
});

// Mouse wheel zoom
canvasWrap.addEventListener('wheel', e => {
  e.preventDefault();
  if (!state.image) return;
  const factor = e.deltaY > 0 ? 1.1 : 0.9;
  const svgP = clientToSVG(e.clientX, e.clientY);
  state.viewBox.w *= factor;
  state.viewBox.h *= factor;
  const newSvgP = clientToSVG(e.clientX, e.clientY);
  state.viewBox.x += svgP.x - newSvgP.x;
  state.viewBox.y += svgP.y - newSvgP.y;
  clampViewBox();
  updateSVGViewBox();
}, { passive: false });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SVG CANVAS TAPS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let tapMoved = false;
let tapStartPt = null;

canvasWrap.addEventListener('touchstart', e => {
  if (e.touches.length !== 1) return;
  tapMoved = false;
  tapStartPt = { x: e.touches[0].clientX, y: e.touches[0].clientY };
}, { passive: true });

canvasWrap.addEventListener('touchmove', e => {
  if (!tapStartPt) return;
  const dx = e.touches[0].clientX - tapStartPt.x;
  const dy = e.touches[0].clientY - tapStartPt.y;
  if (Math.sqrt(dx*dx + dy*dy) > 8) tapMoved = true;
}, { passive: true });

canvasWrap.addEventListener('touchend', e => {
  if (tapMoved || state.isDragging) return;
  if (e.changedTouches.length !== 1) return;
  const t = e.changedTouches[0];
  // Only handle taps on the background (not handles/ROI shapes)
  if (e.target.dataset.handle || e.target.dataset.roiClick) return;
  const pt = clientToSVG(t.clientX, t.clientY);
  handleCanvasTap(pt, t.clientX, t.clientY);
}, { passive: true });

// Mouse click fallback
canvasWrap.addEventListener('click', e => {
  if (e.target.dataset.handle || e.target.dataset.roiClick) return;
  const pt = clientToSVG(e.clientX, e.clientY);
  handleCanvasTap(pt, e.clientX, e.clientY);
});

function handleCanvasTap(pt, cx, cy) {
  if (!state.image) return;

  if (state.mode === 'calib') {
    // Show name modal then place calib circle
    pendingRoiType = 'circle';
    pendingCalib = true;
    pendingCenter = pt;
    modalNameTitle.textContent = 'âŠ™ KALIBRIERUNGS-KREIS';
    inputRoiName.value = 'Fangradius';
    openModal(modalName);
    return;
  }

  if (state.mode === 'circle') {
    pendingRoiType = 'circle';
    pendingCalib = false;
    pendingCenter = pt;
    modalNameTitle.textContent = 'â—‹ NEUER KREIS';
    inputRoiName.value = '';
    openModal(modalName);
    return;
  }

  if (state.mode === 'polygon') {
    addPolygonPoint(pt);
    return;
  }
}

// â”€â”€â”€ Pending state for modals â”€â”€â”€
let pendingRoiType = null;
let pendingCalib = false;
let pendingCenter = null;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MODAL LOGIC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function openModal(m) {
  m.classList.add('open');
  setTimeout(() => m.querySelector('input')?.focus(), 100);
}
function closeModal(m) {
  m.classList.remove('open');
}

modalNameCancel.addEventListener('click', () => {
  closeModal(modalName);
  pendingRoiType = null;
  if (state.mode !== 'polygon') setMode('select');
});

modalNameOk.addEventListener('click', () => {
  const name = inputRoiName.value.trim() || ('ROI_' + (roiCounter + 1));
  closeModal(modalName);

  if (pendingRoiType === 'circle') {
    const roi = createCircleROI(name, pendingCenter, pendingCalib);
    if (pendingCalib) {
      // Show calib modal
      openModal(modalCalib);
    }
  } else if (pendingRoiType === 'polygon') {
    pendingPolyName = name;
    state.mode = 'polygon';
    // Mode was already polygon, just set the name and continue
  }
  pendingRoiType = null;
});

inputRoiName.addEventListener('keydown', e => {
  if (e.key === 'Enter') modalNameOk.click();
});

modalCalibCancel.addEventListener('click', () => closeModal(modalCalib));
modalCalibOk.addEventListener('click', () => {
  const units = parseFloat(inputCalibUnits.value);
  if (!units || units <= 0) return;
  const roi = state.rois.find(r => r.id === state.calibROI);
  if (roi) {
    state.unitPerPx = units / roi.geometry.r;
    updateStatus();
  }
  closeModal(modalCalib);
  setMode('select');
});

inputCalibUnits.addEventListener('keydown', e => {
  if (e.key === 'Enter') modalCalibOk.click();
});

// Calib button re-open
toolCalib.addEventListener('click', () => {
  if (!state.image) return;
  if (state.calibROI) {
    // Re-calibrate existing
    openModal(modalCalib);
    return;
  }
  setMode('calib');
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ROI CREATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function createCircleROI(name, center, isCalib) {
  // Default radius: 5% of shorter image dimension
  const defaultR = Math.min(state.image.width, state.image.height) * 0.05;
  const id = uid();

  const roi = {
    id,
    name,
    type: 'circle',
    isCalib,
    geometry: { cx: center.x, cy: center.y, r: defaultR },
    svgEls: {},
    handleEls: {},
  };

  state.rois.push(roi);
  if (isCalib) {
    if (state.calibROI) {
      // Remove old calib
      const old = state.rois.find(r => r.id === state.calibROI);
      if (old) removeROISVG(old);
    }
    state.calibROI = id;
  }

  buildCircleSVG(roi);
  setActiveROI(id);
  renderROIList();
  return roi;
}

function buildCircleSVG(roi) {
  const g = roi.geometry;
  const isActive = roi.id === state.activeROI;
  const color = roiColor(roi);

  // Main circle
  const circle = svgEl('circle', {
    cx: g.cx, cy: g.cy, r: g.r,
    fill: color + '12',
    stroke: color,
    'stroke-width': isActive ? 2 : 1,
    opacity: isActive ? 1 : 0.4,
  });
  circle.dataset.roiClick = roi.id;
  circle.addEventListener('click', () => setActiveROI(roi.id));
  circle.addEventListener('touchend', (e) => {
    if (!tapMoved) { e.preventDefault(); setActiveROI(roi.id); }
  });

  layerROIs.appendChild(circle);
  roi.svgEls.circle = circle;

  // Handles: center + radius
  buildCircleHandles(roi);
}

function buildCircleHandles(roi) {
  // Remove old handles
  if (roi.handleEls.center) roi.handleEls.center.remove();
  if (roi.handleEls.radius) roi.handleEls.radius.remove();

  if (roi.id !== state.activeROI) return;

  const g = roi.geometry;
  const color = roiColor(roi);
  const hs = 18; // hit size

  // Center handle
  const centerH = svgEl('circle', {
    cx: g.cx, cy: g.cy, r: hs / 2,
    fill: color,
    stroke: '#0d0f14',
    'stroke-width': 2,
    cursor: 'move',
  });
  centerH.dataset.handle = 'center';
  layerHandles.appendChild(centerH);
  roi.handleEls.center = centerH;
  setupHandleDrag(centerH, roi, 'circle-center');

  // Radius handle (east)
  const radiusH = svgEl('rect', {
    x: g.cx + g.r - hs/2, y: g.cy - hs/2,
    width: hs, height: hs,
    fill: color,
    stroke: '#0d0f14',
    'stroke-width': 2,
    rx: 2,
    cursor: 'ew-resize',
  });
  radiusH.dataset.handle = 'radius';
  layerHandles.appendChild(radiusH);
  roi.handleEls.radius = radiusH;
  setupHandleDrag(radiusH, roi, 'circle-radius');
}

let pendingPolyName = '';

function startPolygonCreation() {
  pendingPolyName = '';
  modalNameTitle.textContent = 'â¬¡ NEUES POLYGON';
  inputRoiName.value = '';
  pendingRoiType = 'polygon';
  openModal(modalName);
}

function addPolygonPoint(pt) {
  if (!pendingPolyName) {
    // Need name first
    startPolygonCreation();
    return;
  }
  state.polyPoints.push({ x: pt.x, y: pt.y });
  renderPolyPreview();
}

function renderPolyPreview() {
  layerPolyPreview.innerHTML = '';
  const pts = state.polyPoints;
  if (pts.length === 0) return;

  const color = '#e8ff47';

  // Points
  pts.forEach((p, i) => {
    const c = svgEl('circle', {
      cx: p.x, cy: p.y, r: 8,
      fill: color,
      stroke: '#0d0f14',
      'stroke-width': 2,
    });
    layerPolyPreview.appendChild(c);
  });

  // Line
  if (pts.length >= 2) {
    const d = 'M ' + pts.map(p => `${p.x},${p.y}`).join(' L ');
    const path = svgEl('path', {
      d,
      fill: 'none',
      stroke: color,
      'stroke-width': 1.5,
      'stroke-dasharray': '6 4',
    });
    layerPolyPreview.insertBefore(path, layerPolyPreview.firstChild);
  }

  // Close hint
  if (pts.length >= 3) {
    const closeEl = svgEl('circle', {
      cx: pts[0].x, cy: pts[0].y, r: 12,
      fill: 'none',
      stroke: color,
      'stroke-width': 2,
      'stroke-dasharray': '4 2',
      opacity: 0.6,
    });
    layerPolyPreview.appendChild(closeEl);
  }
}

function closePolygon() {
  const pts = state.polyPoints;
  if (pts.length < 3) return;

  const id = uid();
  const roi = {
    id,
    name: pendingPolyName || ('Polygon_' + roiCounter),
    type: 'polygon',
    isCalib: false,
    geometry: { points: pts.map(p => ({ ...p })) },
    svgEls: {},
    handleEls: {},
  };

  state.rois.push(roi);
  layerPolyPreview.innerHTML = '';
  state.polyPoints = [];
  pendingPolyName = '';

  buildPolygonSVG(roi);
  setActiveROI(id);
  renderROIList();
  setMode('select');
}

function cancelPolygon() {
  state.polyPoints = [];
  pendingPolyName = '';
  layerPolyPreview.innerHTML = '';
}

function buildPolygonSVG(roi) {
  const pts = roi.geometry.points;
  const isActive = roi.id === state.activeROI;
  const color = roiColor(roi);

  const pointsStr = pts.map(p => `${p.x},${p.y}`).join(' ');
  const poly = svgEl('polygon', {
    points: pointsStr,
    fill: color + '10',
    stroke: color,
    'stroke-width': isActive ? 2 : 1,
    opacity: isActive ? 1 : 0.4,
  });
  poly.dataset.roiClick = roi.id;
  poly.addEventListener('click', () => setActiveROI(roi.id));
  poly.addEventListener('touchend', (e) => {
    if (!tapMoved) { e.preventDefault(); setActiveROI(roi.id); }
  });

  layerROIs.appendChild(poly);
  roi.svgEls.polygon = poly;

  buildPolygonHandles(roi);
}

function buildPolygonHandles(roi) {
  // Remove old
  if (roi.handleEls.points) roi.handleEls.points.forEach(h => h.remove());
  if (roi.handleEls.midpoints) roi.handleEls.midpoints.forEach(h => h.remove());
  roi.handleEls.points = [];
  roi.handleEls.midpoints = [];

  if (roi.id !== state.activeROI) return;

  const pts = roi.geometry.points;
  const color = roiColor(roi);
  const hs = 18;

  pts.forEach((p, i) => {
    const h = svgEl('circle', {
      cx: p.x, cy: p.y, r: hs / 2,
      fill: color,
      stroke: '#0d0f14',
      'stroke-width': 2,
      cursor: 'move',
    });
    h.dataset.handle = 'poly-' + i;
    layerHandles.appendChild(h);
    roi.handleEls.points.push(h);
    setupHandleDrag(h, roi, 'poly-point', i);

    // Long press to delete point
    let longPressTimer = null;
    h.addEventListener('touchstart', () => {
      longPressTimer = setTimeout(() => {
        if (pts.length > 3) {
          pts.splice(i, 1);
          rebuildROISVG(roi);
        }
      }, 600);
    }, { passive: true });
    h.addEventListener('touchend', () => clearTimeout(longPressTimer));
    h.addEventListener('touchmove', () => clearTimeout(longPressTimer));
  });

  // Midpoint handles (insert new point)
  pts.forEach((p, i) => {
    const next = pts[(i + 1) % pts.length];
    const mx = (p.x + next.x) / 2;
    const my = (p.y + next.y) / 2;
    const mh = svgEl('rect', {
      x: mx - 7, y: my - 7,
      width: 14, height: 14,
      fill: '#0d0f14',
      stroke: color,
      'stroke-width': 1.5,
      rx: 2,
      opacity: 0.7,
      cursor: 'copy',
    });
    mh.dataset.handle = 'poly-mid-' + i;

    // Tap to insert point
    let midMoved = false;
    let midStart = null;
    mh.addEventListener('touchstart', e => {
      midMoved = false;
      midStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }, { passive: true });
    mh.addEventListener('touchmove', e => {
      if (!midStart) return;
      const dx = e.touches[0].clientX - midStart.x;
      const dy = e.touches[0].clientY - midStart.y;
      if (Math.sqrt(dx*dx+dy*dy) > 6) midMoved = true;
    }, { passive: true });
    mh.addEventListener('touchend', e => {
      if (!midMoved) {
        pts.splice(i + 1, 0, { x: mx, y: my });
        rebuildROISVG(roi);
      }
    });
    mh.addEventListener('click', () => {
      pts.splice(i + 1, 0, { x: mx, y: my });
      rebuildROISVG(roi);
    });

    layerHandles.appendChild(mh);
    roi.handleEls.midpoints.push(mh);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HANDLE DRAG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function setupHandleDrag(el, roi, type, idx) {
  let startSvgPt = null;
  let startGeom = null;

  function onStart(clientX, clientY) {
    state.isDragging = true;
    state.pan.active = false;
    startSvgPt = clientToSVG(clientX, clientY);
    startGeom = JSON.parse(JSON.stringify(roi.geometry));
  }

  function onMove(clientX, clientY) {
    if (!state.isDragging) return;
    const pt = clientToSVG(clientX, clientY);
    const dx = pt.x - startSvgPt.x;
    const dy = pt.y - startSvgPt.y;

    if (type === 'circle-center') {
      roi.geometry.cx = startGeom.cx + dx;
      roi.geometry.cy = startGeom.cy + dy;
    } else if (type === 'circle-radius') {
      const newR = Math.sqrt(
        Math.pow(pt.x - roi.geometry.cx, 2) +
        Math.pow(pt.y - roi.geometry.cy, 2)
      );
      roi.geometry.r = Math.max(5, newR);
    } else if (type === 'poly-point') {
      roi.geometry.points[idx].x = startGeom.points[idx].x + dx;
      roi.geometry.points[idx].y = startGeom.points[idx].y + dy;
    }

    updateROISVG(roi);
    updateStatusCoords(pt);
  }

  function onEnd() {
    state.isDragging = false;
    if (roi.id === state.calibROI && state.unitPerPx) {
      // Recalc if calib roi changed
      // (user may need to re-enter units after resize)
    }
  }

  // Touch
  el.addEventListener('touchstart', e => {
    e.stopPropagation();
    e.preventDefault();
    const t = e.touches[0];
    onStart(t.clientX, t.clientY);
  }, { passive: false });

  el.addEventListener('touchmove', e => {
    e.stopPropagation();
    e.preventDefault();
    const t = e.touches[0];
    onMove(t.clientX, t.clientY);
  }, { passive: false });

  el.addEventListener('touchend', e => {
    e.stopPropagation();
    onEnd();
  });

  // Mouse
  el.addEventListener('mousedown', e => {
    e.stopPropagation();
    onStart(e.clientX, e.clientY);

    const mm = ev => onMove(ev.clientX, ev.clientY);
    const mu = () => { onEnd(); document.removeEventListener('mousemove', mm); document.removeEventListener('mouseup', mu); };
    document.addEventListener('mousemove', mm);
    document.addEventListener('mouseup', mu);
  });
}

function updateStatusCoords(pt) {
  const u = state.unitPerPx;
  if (u) {
    statusCoords.querySelector('span').textContent =
      `${(pt.x * u).toFixed(1)}, ${(pt.y * u).toFixed(1)}`;
  } else {
    statusCoords.querySelector('span').textContent =
      `${pt.x.toFixed(0)}, ${pt.y.toFixed(0)}px`;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDER / REBUILD ROI SVG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function rebuildROISVG(roi) {
  removeROISVG(roi);
  if (roi.type === 'circle') buildCircleSVG(roi);
  else if (roi.type === 'polygon') buildPolygonSVG(roi);
}

function removeROISVG(roi) {
  Object.values(roi.svgEls).forEach(el => el?.remove());
  Object.values(roi.handleEls).forEach(el => {
    if (Array.isArray(el)) el.forEach(e => e?.remove());
    else el?.remove();
  });
  roi.svgEls = {};
  roi.handleEls = {};
}

function updateROISVG(roi) {
  const g = roi.geometry;
  const color = roiColor(roi);

  if (roi.type === 'circle') {
    const c = roi.svgEls.circle;
    if (c) {
      c.setAttribute('cx', g.cx);
      c.setAttribute('cy', g.cy);
      c.setAttribute('r', g.r);
    }
    // Update radius handle
    if (roi.handleEls.center) {
      roi.handleEls.center.setAttribute('cx', g.cx);
      roi.handleEls.center.setAttribute('cy', g.cy);
    }
    if (roi.handleEls.radius) {
      const hs = 18;
      roi.handleEls.radius.setAttribute('x', g.cx + g.r - hs/2);
      roi.handleEls.radius.setAttribute('y', g.cy - hs/2);
    }
  } else if (roi.type === 'polygon') {
    const p = roi.svgEls.polygon;
    if (p) {
      p.setAttribute('points', g.points.map(pt => `${pt.x},${pt.y}`).join(' '));
    }
    // Update handles
    if (roi.handleEls.points) {
      roi.handleEls.points.forEach((h, i) => {
        if (g.points[i]) {
          h.setAttribute('cx', g.points[i].x);
          h.setAttribute('cy', g.points[i].y);
        }
      });
    }
    if (roi.handleEls.midpoints) {
      roi.handleEls.midpoints.forEach((h, i) => {
        const p0 = g.points[i];
        const p1 = g.points[(i + 1) % g.points.length];
        if (p0 && p1) {
          h.setAttribute('x', (p0.x + p1.x) / 2 - 7);
          h.setAttribute('y', (p0.y + p1.y) / 2 - 7);
        }
      });
    }
  }
}

function renderAllROIs() {
  // Rebuild all SVG with correct active state
  state.rois.forEach(roi => rebuildROISVG(roi));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ROI LIST DROPDOWN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
roiDropdownHeader.addEventListener('click', () => {
  const isOpen = roiList.classList.toggle('open');
  roiDropdownHeaderEl.classList.toggle('open', isOpen);
  roiChevron.classList.toggle('open', isOpen);
});

function renderROIList() {
  roiList.innerHTML = '';
  if (state.rois.length === 0) {
    roiList.innerHTML = '<div style="padding:12px 14px;font-family:Share Tech Mono,monospace;font-size:11px;color:#5a6280">Keine ROIs vorhanden</div>';
    return;
  }

  state.rois.forEach(roi => {
    const item = document.createElement('div');
    item.className = 'roi-item' + (roi.id === state.activeROI ? ' active' : '');

    const color = roiColor(roi);
    item.innerHTML = `
      <div class="roi-dot" style="background:${color}"></div>
      <div class="roi-item-name">${roi.name}</div>
      <div class="roi-item-type">${roi.isCalib ? 'âŠ™' : roi.type === 'circle' ? 'â—‹' : 'â¬¡'}</div>
      <div class="roi-del" data-del="${roi.id}">âœ•</div>
    `;

    item.addEventListener('click', (e) => {
      if (e.target.dataset.del) {
        deleteROI(e.target.dataset.del);
        return;
      }
      setActiveROI(roi.id);
      roiList.classList.remove('open');
      roiDropdownHeaderEl.classList.remove('open');
      roiChevron.classList.remove('open');
    });

    // Long press to rename
    let rlt = null;
    item.addEventListener('touchstart', () => {
      rlt = setTimeout(() => {
        inputRename.value = roi.name;
        modalRenameOk.dataset.roiId = roi.id;
        openModal(modalRename);
      }, 600);
    }, { passive: true });
    item.addEventListener('touchend', () => clearTimeout(rlt));
    item.addEventListener('touchmove', () => clearTimeout(rlt));

    roiList.appendChild(item);
  });

  updateDropdownLabel();
}

function deleteROI(id) {
  const idx = state.rois.findIndex(r => r.id === id);
  if (idx === -1) return;
  const roi = state.rois[idx];
  removeROISVG(roi);
  state.rois.splice(idx, 1);
  if (state.calibROI === id) state.calibROI = null;
  if (state.activeROI === id) {
    state.activeROI = state.rois.length > 0 ? state.rois[state.rois.length - 1].id : null;
  }
  renderROIList();
  renderAllROIs();
}

modalRenameCancel.addEventListener('click', () => closeModal(modalRename));
modalRenameOk.addEventListener('click', () => {
  const id = modalRenameOk.dataset.roiId;
  const roi = state.rois.find(r => r.id === id);
  if (roi) {
    roi.name = inputRename.value.trim() || roi.name;
    renderROIList();
    renderAllROIs();
  }
  closeModal(modalRename);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TOOL BUTTONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
toolSelect.addEventListener('click', () => setMode('select'));

toolCircle.addEventListener('click', () => {
  if (!state.image) return;
  setMode('circle');
});

toolPolygon.addEventListener('click', () => {
  if (!state.image) return;
  if (state.mode === 'polygon' && state.polyPoints.length >= 3) {
    // Double-tap the button closes the polygon
    closePolygon();
    return;
  }
  setMode('polygon');
  if (!pendingPolyName) startPolygonCreation();
});

// Double tap on polygon tool = close polygon
let polyBtnTapTime = 0;
toolPolygon.addEventListener('touchend', e => {
  const now = Date.now();
  if (now - polyBtnTapTime < 400 && state.polyPoints.length >= 3) {
    closePolygon();
    e.preventDefault();
  }
  polyBtnTapTime = now;
});

// Also: tap on first polygon point to close
canvasWrap.addEventListener('touchend', e => {
  if (state.mode !== 'polygon' || state.polyPoints.length < 3) return;
  if (tapMoved) return;
  const t = e.changedTouches[0];
  const pt = clientToSVG(t.clientX, t.clientY);
  const first = state.polyPoints[0];
  const dist = Math.sqrt(Math.pow(pt.x - first.x, 2) + Math.pow(pt.y - first.y, 2));
  // Close threshold in px on screen
  const rect = canvasWrap.getBoundingClientRect();
  const pxPerSvg = rect.width / state.viewBox.w;
  const screenDist = dist * pxPerSvg;
  if (screenDist < 24) {
    closePolygon();
  }
}, { passive: true });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JSON EXPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function angleOfSegment(p1, p2) {
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  let angle = Math.atan2(dy, dx) * (180 / Math.PI);
  if (angle < 0) angle += 360;
  return Math.round(angle * 10) / 10;
}

btnExport.addEventListener('click', () => {
  const u = state.unitPerPx || 1;
  const hasCalib = !!state.unitPerPx;

  const exportData = {
    meta: {
      tool: 'WorldMapper v1.0',
      exportedAt: new Date().toISOString(),
      imageSize: state.image ? { width: state.image.width, height: state.image.height } : null,
      calibrated: hasCalib,
      unitPerPx: state.unitPerPx ?? null,
      coordinateOrigin: 'top-left',
    },
    rois: state.rois.map(roi => {
      const base = {
        id: roi.id,
        name: roi.name,
        type: roi.type,
        isCalibrationROI: roi.isCalib || false,
      };

      if (roi.type === 'circle') {
        const g = roi.geometry;
        return {
          ...base,
          pixels: {
            cx: Math.round(g.cx * 100) / 100,
            cy: Math.round(g.cy * 100) / 100,
            r: Math.round(g.r * 100) / 100,
          },
          units: hasCalib ? {
            cx: Math.round(g.cx * u * 100) / 100,
            cy: Math.round(g.cy * u * 100) / 100,
            r: Math.round(g.r * u * 100) / 100,
          } : null,
        };
      } else if (roi.type === 'polygon') {
        const pts = roi.geometry.points;
        const edges = pts.map((p, i) => {
          const next = pts[(i + 1) % pts.length];
          const dx = next.x - p.x;
          const dy = next.y - p.y;
          const lenPx = Math.sqrt(dx*dx + dy*dy);
          return {
            from: i,
            to: (i + 1) % pts.length,
            lengthPx: Math.round(lenPx * 100) / 100,
            lengthUnits: hasCalib ? Math.round(lenPx * u * 100) / 100 : null,
            angleDeg: angleOfSegment(p, next),
          };
        });

        return {
          ...base,
          pixels: {
            points: pts.map(p => ({
              x: Math.round(p.x * 100) / 100,
              y: Math.round(p.y * 100) / 100,
            })),
          },
          units: hasCalib ? {
            points: pts.map(p => ({
              x: Math.round(p.x * u * 100) / 100,
              y: Math.round(p.y * u * 100) / 100,
            })),
          } : null,
          edges,
        };
      }
      return base;
    }),
  };

  const json = JSON.stringify(exportData, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'worldmap_' + new Date().toISOString().slice(0,10) + '.json';
  a.click();
  URL.revokeObjectURL(url);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POLYGON CREATION â€” start via toolbar
// (modal name callback connects to pending poly)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// patch modalNameOk to handle polygon correctly
const _origNameOk = modalNameOk.onclick;
modalNameOk.addEventListener('click', () => {
  if (pendingRoiType === 'polygon') {
    pendingPolyName = inputRoiName.value.trim() || ('Polygon_' + (roiCounter + 1));
    closeModal(modalName);
    pendingRoiType = null;
    setMode('polygon');
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
setMode('select');
updateStatus();

// Prevent default context menu on long press
document.addEventListener('contextmenu', e => e.preventDefault());
</script>

</body>
</html>
